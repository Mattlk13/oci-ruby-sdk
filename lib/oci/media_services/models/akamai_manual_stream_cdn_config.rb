# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20211101
require 'date'
require 'logger'
require_relative 'stream_cdn_config_section'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Configuration fields for manual Akamai configuration.
  class MediaServices::Models::AkamaiManualStreamCdnConfig < MediaServices::Models::StreamCdnConfigSection
    ORIGIN_AUTH_SIGN_TYPE_ENUM = [
      ORIGIN_AUTH_SIGN_TYPE_FORWARD_URL = 'ForwardURL'.freeze,
      ORIGIN_AUTH_SIGN_TYPE_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    ORIGIN_AUTH_SIGN_ENCRYPTION_ENUM = [
      ORIGIN_AUTH_SIGN_ENCRYPTION_SHA256_HMAC = 'SHA256-HMAC'.freeze,
      ORIGIN_AUTH_SIGN_ENCRYPTION_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # The type of data used to compute the signature.
    # @return [String]
    attr_reader :origin_auth_sign_type

    # The type of encryption used to compute the signature.
    # @return [String]
    attr_reader :origin_auth_sign_encryption

    # The shared secret key A, two for errorless key rotation.
    # @return [String]
    attr_accessor :origin_auth_secret_key_a

    # Nonce identifier for originAuthSecretKeyA (used to determine key used to sign).
    # @return [String]
    attr_accessor :origin_auth_secret_key_nonce_a

    # The shared secret key B, two for errorless key rotation.
    # @return [String]
    attr_accessor :origin_auth_secret_key_b

    # Nonce identifier for originAuthSecretKeyB (used to determine key used to sign).
    # @return [String]
    attr_accessor :origin_auth_secret_key_nonce_b

    # The hostname of the CDN edge server to use when building CDN URLs.
    # @return [String]
    attr_accessor :edge_hostname

    # The path to prepend when building CDN URLs.
    # @return [String]
    attr_accessor :edge_path_prefix

    # Whether token authentication should be used at the CDN edge.
    # @return [BOOLEAN]
    attr_accessor :is_edge_token_auth

    # The encryption key to use for edge token authentication.
    # @return [String]
    attr_accessor :edge_token_key

    # Salt to use when encrypting authentication token.
    # @return [String]
    attr_accessor :edge_token_salt

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'type': :'type',
        'origin_auth_sign_type': :'originAuthSignType',
        'origin_auth_sign_encryption': :'originAuthSignEncryption',
        'origin_auth_secret_key_a': :'originAuthSecretKeyA',
        'origin_auth_secret_key_nonce_a': :'originAuthSecretKeyNonceA',
        'origin_auth_secret_key_b': :'originAuthSecretKeyB',
        'origin_auth_secret_key_nonce_b': :'originAuthSecretKeyNonceB',
        'edge_hostname': :'edgeHostname',
        'edge_path_prefix': :'edgePathPrefix',
        'is_edge_token_auth': :'isEdgeTokenAuth',
        'edge_token_key': :'edgeTokenKey',
        'edge_token_salt': :'edgeTokenSalt'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'type': :'String',
        'origin_auth_sign_type': :'String',
        'origin_auth_sign_encryption': :'String',
        'origin_auth_secret_key_a': :'String',
        'origin_auth_secret_key_nonce_a': :'String',
        'origin_auth_secret_key_b': :'String',
        'origin_auth_secret_key_nonce_b': :'String',
        'edge_hostname': :'String',
        'edge_path_prefix': :'String',
        'is_edge_token_auth': :'BOOLEAN',
        'edge_token_key': :'String',
        'edge_token_salt': :'String'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :origin_auth_sign_type The value to assign to the {#origin_auth_sign_type} property
    # @option attributes [String] :origin_auth_sign_encryption The value to assign to the {#origin_auth_sign_encryption} property
    # @option attributes [String] :origin_auth_secret_key_a The value to assign to the {#origin_auth_secret_key_a} property
    # @option attributes [String] :origin_auth_secret_key_nonce_a The value to assign to the {#origin_auth_secret_key_nonce_a} property
    # @option attributes [String] :origin_auth_secret_key_b The value to assign to the {#origin_auth_secret_key_b} property
    # @option attributes [String] :origin_auth_secret_key_nonce_b The value to assign to the {#origin_auth_secret_key_nonce_b} property
    # @option attributes [String] :edge_hostname The value to assign to the {#edge_hostname} property
    # @option attributes [String] :edge_path_prefix The value to assign to the {#edge_path_prefix} property
    # @option attributes [BOOLEAN] :is_edge_token_auth The value to assign to the {#is_edge_token_auth} property
    # @option attributes [String] :edge_token_key The value to assign to the {#edge_token_key} property
    # @option attributes [String] :edge_token_salt The value to assign to the {#edge_token_salt} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      attributes['type'] = 'AKAMAI_MANUAL'

      super(attributes)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.origin_auth_sign_type = attributes[:'originAuthSignType'] if attributes[:'originAuthSignType']
      self.origin_auth_sign_type = "ForwardURL" if origin_auth_sign_type.nil? && !attributes.key?(:'originAuthSignType') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :originAuthSignType and :origin_auth_sign_type' if attributes.key?(:'originAuthSignType') && attributes.key?(:'origin_auth_sign_type')

      self.origin_auth_sign_type = attributes[:'origin_auth_sign_type'] if attributes[:'origin_auth_sign_type']
      self.origin_auth_sign_type = "ForwardURL" if origin_auth_sign_type.nil? && !attributes.key?(:'originAuthSignType') && !attributes.key?(:'origin_auth_sign_type') # rubocop:disable Style/StringLiterals

      self.origin_auth_sign_encryption = attributes[:'originAuthSignEncryption'] if attributes[:'originAuthSignEncryption']
      self.origin_auth_sign_encryption = "SHA256-HMAC" if origin_auth_sign_encryption.nil? && !attributes.key?(:'originAuthSignEncryption') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :originAuthSignEncryption and :origin_auth_sign_encryption' if attributes.key?(:'originAuthSignEncryption') && attributes.key?(:'origin_auth_sign_encryption')

      self.origin_auth_sign_encryption = attributes[:'origin_auth_sign_encryption'] if attributes[:'origin_auth_sign_encryption']
      self.origin_auth_sign_encryption = "SHA256-HMAC" if origin_auth_sign_encryption.nil? && !attributes.key?(:'originAuthSignEncryption') && !attributes.key?(:'origin_auth_sign_encryption') # rubocop:disable Style/StringLiterals

      self.origin_auth_secret_key_a = attributes[:'originAuthSecretKeyA'] if attributes[:'originAuthSecretKeyA']

      raise 'You cannot provide both :originAuthSecretKeyA and :origin_auth_secret_key_a' if attributes.key?(:'originAuthSecretKeyA') && attributes.key?(:'origin_auth_secret_key_a')

      self.origin_auth_secret_key_a = attributes[:'origin_auth_secret_key_a'] if attributes[:'origin_auth_secret_key_a']

      self.origin_auth_secret_key_nonce_a = attributes[:'originAuthSecretKeyNonceA'] if attributes[:'originAuthSecretKeyNonceA']
      self.origin_auth_secret_key_nonce_a = "nonceKeyA" if origin_auth_secret_key_nonce_a.nil? && !attributes.key?(:'originAuthSecretKeyNonceA') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :originAuthSecretKeyNonceA and :origin_auth_secret_key_nonce_a' if attributes.key?(:'originAuthSecretKeyNonceA') && attributes.key?(:'origin_auth_secret_key_nonce_a')

      self.origin_auth_secret_key_nonce_a = attributes[:'origin_auth_secret_key_nonce_a'] if attributes[:'origin_auth_secret_key_nonce_a']
      self.origin_auth_secret_key_nonce_a = "nonceKeyA" if origin_auth_secret_key_nonce_a.nil? && !attributes.key?(:'originAuthSecretKeyNonceA') && !attributes.key?(:'origin_auth_secret_key_nonce_a') # rubocop:disable Style/StringLiterals

      self.origin_auth_secret_key_b = attributes[:'originAuthSecretKeyB'] if attributes[:'originAuthSecretKeyB']

      raise 'You cannot provide both :originAuthSecretKeyB and :origin_auth_secret_key_b' if attributes.key?(:'originAuthSecretKeyB') && attributes.key?(:'origin_auth_secret_key_b')

      self.origin_auth_secret_key_b = attributes[:'origin_auth_secret_key_b'] if attributes[:'origin_auth_secret_key_b']

      self.origin_auth_secret_key_nonce_b = attributes[:'originAuthSecretKeyNonceB'] if attributes[:'originAuthSecretKeyNonceB']
      self.origin_auth_secret_key_nonce_b = "nonceKeyB" if origin_auth_secret_key_nonce_b.nil? && !attributes.key?(:'originAuthSecretKeyNonceB') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :originAuthSecretKeyNonceB and :origin_auth_secret_key_nonce_b' if attributes.key?(:'originAuthSecretKeyNonceB') && attributes.key?(:'origin_auth_secret_key_nonce_b')

      self.origin_auth_secret_key_nonce_b = attributes[:'origin_auth_secret_key_nonce_b'] if attributes[:'origin_auth_secret_key_nonce_b']
      self.origin_auth_secret_key_nonce_b = "nonceKeyB" if origin_auth_secret_key_nonce_b.nil? && !attributes.key?(:'originAuthSecretKeyNonceB') && !attributes.key?(:'origin_auth_secret_key_nonce_b') # rubocop:disable Style/StringLiterals

      self.edge_hostname = attributes[:'edgeHostname'] if attributes[:'edgeHostname']

      raise 'You cannot provide both :edgeHostname and :edge_hostname' if attributes.key?(:'edgeHostname') && attributes.key?(:'edge_hostname')

      self.edge_hostname = attributes[:'edge_hostname'] if attributes[:'edge_hostname']

      self.edge_path_prefix = attributes[:'edgePathPrefix'] if attributes[:'edgePathPrefix']

      raise 'You cannot provide both :edgePathPrefix and :edge_path_prefix' if attributes.key?(:'edgePathPrefix') && attributes.key?(:'edge_path_prefix')

      self.edge_path_prefix = attributes[:'edge_path_prefix'] if attributes[:'edge_path_prefix']

      self.is_edge_token_auth = attributes[:'isEdgeTokenAuth'] unless attributes[:'isEdgeTokenAuth'].nil?

      raise 'You cannot provide both :isEdgeTokenAuth and :is_edge_token_auth' if attributes.key?(:'isEdgeTokenAuth') && attributes.key?(:'is_edge_token_auth')

      self.is_edge_token_auth = attributes[:'is_edge_token_auth'] unless attributes[:'is_edge_token_auth'].nil?

      self.edge_token_key = attributes[:'edgeTokenKey'] if attributes[:'edgeTokenKey']

      raise 'You cannot provide both :edgeTokenKey and :edge_token_key' if attributes.key?(:'edgeTokenKey') && attributes.key?(:'edge_token_key')

      self.edge_token_key = attributes[:'edge_token_key'] if attributes[:'edge_token_key']

      self.edge_token_salt = attributes[:'edgeTokenSalt'] if attributes[:'edgeTokenSalt']

      raise 'You cannot provide both :edgeTokenSalt and :edge_token_salt' if attributes.key?(:'edgeTokenSalt') && attributes.key?(:'edge_token_salt')

      self.edge_token_salt = attributes[:'edge_token_salt'] if attributes[:'edge_token_salt']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] origin_auth_sign_type Object to be assigned
    def origin_auth_sign_type=(origin_auth_sign_type)
      # rubocop:disable Style/ConditionalAssignment
      if origin_auth_sign_type && !ORIGIN_AUTH_SIGN_TYPE_ENUM.include?(origin_auth_sign_type)
        OCI.logger.debug("Unknown value for 'origin_auth_sign_type' [" + origin_auth_sign_type + "]. Mapping to 'ORIGIN_AUTH_SIGN_TYPE_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @origin_auth_sign_type = ORIGIN_AUTH_SIGN_TYPE_UNKNOWN_ENUM_VALUE
      else
        @origin_auth_sign_type = origin_auth_sign_type
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] origin_auth_sign_encryption Object to be assigned
    def origin_auth_sign_encryption=(origin_auth_sign_encryption)
      # rubocop:disable Style/ConditionalAssignment
      if origin_auth_sign_encryption && !ORIGIN_AUTH_SIGN_ENCRYPTION_ENUM.include?(origin_auth_sign_encryption)
        OCI.logger.debug("Unknown value for 'origin_auth_sign_encryption' [" + origin_auth_sign_encryption + "]. Mapping to 'ORIGIN_AUTH_SIGN_ENCRYPTION_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @origin_auth_sign_encryption = ORIGIN_AUTH_SIGN_ENCRYPTION_UNKNOWN_ENUM_VALUE
      else
        @origin_auth_sign_encryption = origin_auth_sign_encryption
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        type == other.type &&
        origin_auth_sign_type == other.origin_auth_sign_type &&
        origin_auth_sign_encryption == other.origin_auth_sign_encryption &&
        origin_auth_secret_key_a == other.origin_auth_secret_key_a &&
        origin_auth_secret_key_nonce_a == other.origin_auth_secret_key_nonce_a &&
        origin_auth_secret_key_b == other.origin_auth_secret_key_b &&
        origin_auth_secret_key_nonce_b == other.origin_auth_secret_key_nonce_b &&
        edge_hostname == other.edge_hostname &&
        edge_path_prefix == other.edge_path_prefix &&
        is_edge_token_auth == other.is_edge_token_auth &&
        edge_token_key == other.edge_token_key &&
        edge_token_salt == other.edge_token_salt
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [type, origin_auth_sign_type, origin_auth_sign_encryption, origin_auth_secret_key_a, origin_auth_secret_key_nonce_a, origin_auth_secret_key_b, origin_auth_secret_key_nonce_b, edge_hostname, edge_path_prefix, is_edge_token_auth, edge_token_key, edge_token_salt].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
