# Copyright (c) 2016, 2025, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20200630
require 'date'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # MySql Sql Stats type object.
  class Opsi::Models::MySqlSqlStats
    # **[Required]** Unique SQL ID Digest for a MySql Statement.
    # Example: `\"c20fcea11911be36651b7ca7bd3712d4ed9ac1134cee9c6620039e1fb13b5eff\"`
    #
    # @return [String]
    attr_accessor :digest

    # **[Required]** Collection timestamp.
    # Example: `\"2020-03-31T00:00:00.000Z\"`
    #
    # @return [DateTime]
    attr_accessor :time_collected

    # Type of statement such as select, update or delete.
    # @return [String]
    attr_accessor :command_type

    # Total number of SQL statements used in collection ranking calculation.
    # @return [Integer]
    attr_accessor :total_rows

    # Percent of SQL statements in the perf schema table relative to max or overflow count set in @@GLOBAL.performance_schema_digests_size.
    # @return [Integer]
    attr_accessor :perf_schema_used_percent

    # Name of Database Schema.
    # Example: `\"performance_schema\"`
    #
    # @return [String]
    attr_accessor :schema_name

    # The total number of times the statement has executed.
    # @return [Integer]
    attr_accessor :exec_count

    # The total wait time (in picoseconds) of timed occurrences of the statement.
    # @return [Integer]
    attr_accessor :total_latency_in_ps

    # The total time waiting (in picoseconds) for locks by timed occurrences of the statement.
    # @return [Integer]
    attr_accessor :lock_latency_in_ps

    # The total number of errors produced by occurrences of the statement.
    # @return [Integer]
    attr_accessor :err_count

    # The total number of warnings produced by occurrences of the statement.
    # @return [Integer]
    attr_accessor :warn_count

    # The total number of rows affected by occurrences of the statement.
    # @return [Integer]
    attr_accessor :rows_affected

    # The total number of rows returned by occurrences of the statement.
    # @return [Integer]
    attr_accessor :rows_sent

    # The total number of rows read from storage engines by occurrences of the statement.
    # @return [Integer]
    attr_accessor :rows_examined

    # The total number of internal on-disk temporary tables created by occurrences of the statement.
    # @return [Integer]
    attr_accessor :tmp_disk_tables

    # The total number of internal in-memory temporary tables created by occurrences of the statement Count
    # @return [Integer]
    attr_accessor :tmp_tables

    # The total number of joins that perform table scans because they do not use indexes by occurrences of the statement. If this value is not 0
    # @return [Integer]
    attr_accessor :select_full_join

    # The total number of joins that used a range search on a reference table by occurrences of the statement
    # @return [Integer]
    attr_accessor :select_full_range_join

    # The total number of joins that used ranges on the first table by occurrences of the statement. This is normally not a critical issue even if the value is quite large. Count
    # @return [Integer]
    attr_accessor :select_range

    # The total number of joins without keys that check for key usage after each row by occurrences of the statement. If this is not 0
    # @return [Integer]
    attr_accessor :select_range_check

    # The total number of joins that did a full scan of the first table by occurrences of the statement Count
    # @return [Integer]
    attr_accessor :select_scan

    # The total number of sort merge passes by occurrences of the statement.
    # @return [Integer]
    attr_accessor :sort_merge_passes

    # The total number of sorts that were done using ranges by occurrences of the statement.
    # @return [Integer]
    attr_accessor :sort_range

    # The total number of rows sorted by occurrences of the statement.
    # @return [Integer]
    attr_accessor :rows_sorted

    # The total number of sorts that were done by scanning the table by occurrences of the statement.
    # @return [Integer]
    attr_accessor :sort_scan

    # The number of occurences of the statement which performed a table scan without using an index Count
    # @return [Integer]
    attr_accessor :no_index_used_count

    # The number of occurences of the statement where the server found no good index to use Count
    # @return [Integer]
    attr_accessor :no_good_index_used_count

    # The total time spent on CPU (in picoseconds) for the current thread.
    # @return [Integer]
    attr_accessor :cpu_latency_in_ps

    # The maximum amount of controlled memory (in bytes) used by the statement.
    # @return [Integer]
    attr_accessor :max_controlled_memory_in_bytes

    # The maximum amount of memory (in bytes) used by the statement.
    # @return [Integer]
    attr_accessor :max_total_memory_in_bytes

    # The total number of times a query was processed on the secondary engine (HEATWAVE) for occurrences of this statement Count.
    # @return [Integer]
    attr_accessor :exec_count_secondary

    # The time at which statement was first seen.
    # Example: `\"2023-01-16 08:04:31.533577\"`
    #
    # @return [DateTime]
    attr_accessor :time_first_seen

    # The time at which statement was most recently seen for all occurrences of the statement.
    # Example: `\"2023-01-30 02:17:08.067961\"`
    #
    # @return [DateTime]
    attr_accessor :time_last_seen

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'digest': :'digest',
        'time_collected': :'timeCollected',
        'command_type': :'commandType',
        'total_rows': :'totalRows',
        'perf_schema_used_percent': :'perfSchemaUsedPercent',
        'schema_name': :'schemaName',
        'exec_count': :'execCount',
        'total_latency_in_ps': :'totalLatencyInPs',
        'lock_latency_in_ps': :'lockLatencyInPs',
        'err_count': :'errCount',
        'warn_count': :'warnCount',
        'rows_affected': :'rowsAffected',
        'rows_sent': :'rowsSent',
        'rows_examined': :'rowsExamined',
        'tmp_disk_tables': :'tmpDiskTables',
        'tmp_tables': :'tmpTables',
        'select_full_join': :'selectFullJoin',
        'select_full_range_join': :'selectFullRangeJoin',
        'select_range': :'selectRange',
        'select_range_check': :'selectRangeCheck',
        'select_scan': :'selectScan',
        'sort_merge_passes': :'sortMergePasses',
        'sort_range': :'sortRange',
        'rows_sorted': :'rowsSorted',
        'sort_scan': :'sortScan',
        'no_index_used_count': :'noIndexUsedCount',
        'no_good_index_used_count': :'noGoodIndexUsedCount',
        'cpu_latency_in_ps': :'cpuLatencyInPs',
        'max_controlled_memory_in_bytes': :'maxControlledMemoryInBytes',
        'max_total_memory_in_bytes': :'maxTotalMemoryInBytes',
        'exec_count_secondary': :'execCountSecondary',
        'time_first_seen': :'timeFirstSeen',
        'time_last_seen': :'timeLastSeen'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'digest': :'String',
        'time_collected': :'DateTime',
        'command_type': :'String',
        'total_rows': :'Integer',
        'perf_schema_used_percent': :'Integer',
        'schema_name': :'String',
        'exec_count': :'Integer',
        'total_latency_in_ps': :'Integer',
        'lock_latency_in_ps': :'Integer',
        'err_count': :'Integer',
        'warn_count': :'Integer',
        'rows_affected': :'Integer',
        'rows_sent': :'Integer',
        'rows_examined': :'Integer',
        'tmp_disk_tables': :'Integer',
        'tmp_tables': :'Integer',
        'select_full_join': :'Integer',
        'select_full_range_join': :'Integer',
        'select_range': :'Integer',
        'select_range_check': :'Integer',
        'select_scan': :'Integer',
        'sort_merge_passes': :'Integer',
        'sort_range': :'Integer',
        'rows_sorted': :'Integer',
        'sort_scan': :'Integer',
        'no_index_used_count': :'Integer',
        'no_good_index_used_count': :'Integer',
        'cpu_latency_in_ps': :'Integer',
        'max_controlled_memory_in_bytes': :'Integer',
        'max_total_memory_in_bytes': :'Integer',
        'exec_count_secondary': :'Integer',
        'time_first_seen': :'DateTime',
        'time_last_seen': :'DateTime'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :digest The value to assign to the {#digest} property
    # @option attributes [DateTime] :time_collected The value to assign to the {#time_collected} property
    # @option attributes [String] :command_type The value to assign to the {#command_type} property
    # @option attributes [Integer] :total_rows The value to assign to the {#total_rows} property
    # @option attributes [Integer] :perf_schema_used_percent The value to assign to the {#perf_schema_used_percent} property
    # @option attributes [String] :schema_name The value to assign to the {#schema_name} property
    # @option attributes [Integer] :exec_count The value to assign to the {#exec_count} property
    # @option attributes [Integer] :total_latency_in_ps The value to assign to the {#total_latency_in_ps} property
    # @option attributes [Integer] :lock_latency_in_ps The value to assign to the {#lock_latency_in_ps} property
    # @option attributes [Integer] :err_count The value to assign to the {#err_count} property
    # @option attributes [Integer] :warn_count The value to assign to the {#warn_count} property
    # @option attributes [Integer] :rows_affected The value to assign to the {#rows_affected} property
    # @option attributes [Integer] :rows_sent The value to assign to the {#rows_sent} property
    # @option attributes [Integer] :rows_examined The value to assign to the {#rows_examined} property
    # @option attributes [Integer] :tmp_disk_tables The value to assign to the {#tmp_disk_tables} property
    # @option attributes [Integer] :tmp_tables The value to assign to the {#tmp_tables} property
    # @option attributes [Integer] :select_full_join The value to assign to the {#select_full_join} property
    # @option attributes [Integer] :select_full_range_join The value to assign to the {#select_full_range_join} property
    # @option attributes [Integer] :select_range The value to assign to the {#select_range} property
    # @option attributes [Integer] :select_range_check The value to assign to the {#select_range_check} property
    # @option attributes [Integer] :select_scan The value to assign to the {#select_scan} property
    # @option attributes [Integer] :sort_merge_passes The value to assign to the {#sort_merge_passes} property
    # @option attributes [Integer] :sort_range The value to assign to the {#sort_range} property
    # @option attributes [Integer] :rows_sorted The value to assign to the {#rows_sorted} property
    # @option attributes [Integer] :sort_scan The value to assign to the {#sort_scan} property
    # @option attributes [Integer] :no_index_used_count The value to assign to the {#no_index_used_count} property
    # @option attributes [Integer] :no_good_index_used_count The value to assign to the {#no_good_index_used_count} property
    # @option attributes [Integer] :cpu_latency_in_ps The value to assign to the {#cpu_latency_in_ps} property
    # @option attributes [Integer] :max_controlled_memory_in_bytes The value to assign to the {#max_controlled_memory_in_bytes} property
    # @option attributes [Integer] :max_total_memory_in_bytes The value to assign to the {#max_total_memory_in_bytes} property
    # @option attributes [Integer] :exec_count_secondary The value to assign to the {#exec_count_secondary} property
    # @option attributes [DateTime] :time_first_seen The value to assign to the {#time_first_seen} property
    # @option attributes [DateTime] :time_last_seen The value to assign to the {#time_last_seen} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.digest = attributes[:'digest'] if attributes[:'digest']

      self.time_collected = attributes[:'timeCollected'] if attributes[:'timeCollected']

      raise 'You cannot provide both :timeCollected and :time_collected' if attributes.key?(:'timeCollected') && attributes.key?(:'time_collected')

      self.time_collected = attributes[:'time_collected'] if attributes[:'time_collected']

      self.command_type = attributes[:'commandType'] if attributes[:'commandType']

      raise 'You cannot provide both :commandType and :command_type' if attributes.key?(:'commandType') && attributes.key?(:'command_type')

      self.command_type = attributes[:'command_type'] if attributes[:'command_type']

      self.total_rows = attributes[:'totalRows'] if attributes[:'totalRows']

      raise 'You cannot provide both :totalRows and :total_rows' if attributes.key?(:'totalRows') && attributes.key?(:'total_rows')

      self.total_rows = attributes[:'total_rows'] if attributes[:'total_rows']

      self.perf_schema_used_percent = attributes[:'perfSchemaUsedPercent'] if attributes[:'perfSchemaUsedPercent']

      raise 'You cannot provide both :perfSchemaUsedPercent and :perf_schema_used_percent' if attributes.key?(:'perfSchemaUsedPercent') && attributes.key?(:'perf_schema_used_percent')

      self.perf_schema_used_percent = attributes[:'perf_schema_used_percent'] if attributes[:'perf_schema_used_percent']

      self.schema_name = attributes[:'schemaName'] if attributes[:'schemaName']

      raise 'You cannot provide both :schemaName and :schema_name' if attributes.key?(:'schemaName') && attributes.key?(:'schema_name')

      self.schema_name = attributes[:'schema_name'] if attributes[:'schema_name']

      self.exec_count = attributes[:'execCount'] if attributes[:'execCount']

      raise 'You cannot provide both :execCount and :exec_count' if attributes.key?(:'execCount') && attributes.key?(:'exec_count')

      self.exec_count = attributes[:'exec_count'] if attributes[:'exec_count']

      self.total_latency_in_ps = attributes[:'totalLatencyInPs'] if attributes[:'totalLatencyInPs']

      raise 'You cannot provide both :totalLatencyInPs and :total_latency_in_ps' if attributes.key?(:'totalLatencyInPs') && attributes.key?(:'total_latency_in_ps')

      self.total_latency_in_ps = attributes[:'total_latency_in_ps'] if attributes[:'total_latency_in_ps']

      self.lock_latency_in_ps = attributes[:'lockLatencyInPs'] if attributes[:'lockLatencyInPs']

      raise 'You cannot provide both :lockLatencyInPs and :lock_latency_in_ps' if attributes.key?(:'lockLatencyInPs') && attributes.key?(:'lock_latency_in_ps')

      self.lock_latency_in_ps = attributes[:'lock_latency_in_ps'] if attributes[:'lock_latency_in_ps']

      self.err_count = attributes[:'errCount'] if attributes[:'errCount']

      raise 'You cannot provide both :errCount and :err_count' if attributes.key?(:'errCount') && attributes.key?(:'err_count')

      self.err_count = attributes[:'err_count'] if attributes[:'err_count']

      self.warn_count = attributes[:'warnCount'] if attributes[:'warnCount']

      raise 'You cannot provide both :warnCount and :warn_count' if attributes.key?(:'warnCount') && attributes.key?(:'warn_count')

      self.warn_count = attributes[:'warn_count'] if attributes[:'warn_count']

      self.rows_affected = attributes[:'rowsAffected'] if attributes[:'rowsAffected']

      raise 'You cannot provide both :rowsAffected and :rows_affected' if attributes.key?(:'rowsAffected') && attributes.key?(:'rows_affected')

      self.rows_affected = attributes[:'rows_affected'] if attributes[:'rows_affected']

      self.rows_sent = attributes[:'rowsSent'] if attributes[:'rowsSent']

      raise 'You cannot provide both :rowsSent and :rows_sent' if attributes.key?(:'rowsSent') && attributes.key?(:'rows_sent')

      self.rows_sent = attributes[:'rows_sent'] if attributes[:'rows_sent']

      self.rows_examined = attributes[:'rowsExamined'] if attributes[:'rowsExamined']

      raise 'You cannot provide both :rowsExamined and :rows_examined' if attributes.key?(:'rowsExamined') && attributes.key?(:'rows_examined')

      self.rows_examined = attributes[:'rows_examined'] if attributes[:'rows_examined']

      self.tmp_disk_tables = attributes[:'tmpDiskTables'] if attributes[:'tmpDiskTables']

      raise 'You cannot provide both :tmpDiskTables and :tmp_disk_tables' if attributes.key?(:'tmpDiskTables') && attributes.key?(:'tmp_disk_tables')

      self.tmp_disk_tables = attributes[:'tmp_disk_tables'] if attributes[:'tmp_disk_tables']

      self.tmp_tables = attributes[:'tmpTables'] if attributes[:'tmpTables']

      raise 'You cannot provide both :tmpTables and :tmp_tables' if attributes.key?(:'tmpTables') && attributes.key?(:'tmp_tables')

      self.tmp_tables = attributes[:'tmp_tables'] if attributes[:'tmp_tables']

      self.select_full_join = attributes[:'selectFullJoin'] if attributes[:'selectFullJoin']

      raise 'You cannot provide both :selectFullJoin and :select_full_join' if attributes.key?(:'selectFullJoin') && attributes.key?(:'select_full_join')

      self.select_full_join = attributes[:'select_full_join'] if attributes[:'select_full_join']

      self.select_full_range_join = attributes[:'selectFullRangeJoin'] if attributes[:'selectFullRangeJoin']

      raise 'You cannot provide both :selectFullRangeJoin and :select_full_range_join' if attributes.key?(:'selectFullRangeJoin') && attributes.key?(:'select_full_range_join')

      self.select_full_range_join = attributes[:'select_full_range_join'] if attributes[:'select_full_range_join']

      self.select_range = attributes[:'selectRange'] if attributes[:'selectRange']

      raise 'You cannot provide both :selectRange and :select_range' if attributes.key?(:'selectRange') && attributes.key?(:'select_range')

      self.select_range = attributes[:'select_range'] if attributes[:'select_range']

      self.select_range_check = attributes[:'selectRangeCheck'] if attributes[:'selectRangeCheck']

      raise 'You cannot provide both :selectRangeCheck and :select_range_check' if attributes.key?(:'selectRangeCheck') && attributes.key?(:'select_range_check')

      self.select_range_check = attributes[:'select_range_check'] if attributes[:'select_range_check']

      self.select_scan = attributes[:'selectScan'] if attributes[:'selectScan']

      raise 'You cannot provide both :selectScan and :select_scan' if attributes.key?(:'selectScan') && attributes.key?(:'select_scan')

      self.select_scan = attributes[:'select_scan'] if attributes[:'select_scan']

      self.sort_merge_passes = attributes[:'sortMergePasses'] if attributes[:'sortMergePasses']

      raise 'You cannot provide both :sortMergePasses and :sort_merge_passes' if attributes.key?(:'sortMergePasses') && attributes.key?(:'sort_merge_passes')

      self.sort_merge_passes = attributes[:'sort_merge_passes'] if attributes[:'sort_merge_passes']

      self.sort_range = attributes[:'sortRange'] if attributes[:'sortRange']

      raise 'You cannot provide both :sortRange and :sort_range' if attributes.key?(:'sortRange') && attributes.key?(:'sort_range')

      self.sort_range = attributes[:'sort_range'] if attributes[:'sort_range']

      self.rows_sorted = attributes[:'rowsSorted'] if attributes[:'rowsSorted']

      raise 'You cannot provide both :rowsSorted and :rows_sorted' if attributes.key?(:'rowsSorted') && attributes.key?(:'rows_sorted')

      self.rows_sorted = attributes[:'rows_sorted'] if attributes[:'rows_sorted']

      self.sort_scan = attributes[:'sortScan'] if attributes[:'sortScan']

      raise 'You cannot provide both :sortScan and :sort_scan' if attributes.key?(:'sortScan') && attributes.key?(:'sort_scan')

      self.sort_scan = attributes[:'sort_scan'] if attributes[:'sort_scan']

      self.no_index_used_count = attributes[:'noIndexUsedCount'] if attributes[:'noIndexUsedCount']

      raise 'You cannot provide both :noIndexUsedCount and :no_index_used_count' if attributes.key?(:'noIndexUsedCount') && attributes.key?(:'no_index_used_count')

      self.no_index_used_count = attributes[:'no_index_used_count'] if attributes[:'no_index_used_count']

      self.no_good_index_used_count = attributes[:'noGoodIndexUsedCount'] if attributes[:'noGoodIndexUsedCount']

      raise 'You cannot provide both :noGoodIndexUsedCount and :no_good_index_used_count' if attributes.key?(:'noGoodIndexUsedCount') && attributes.key?(:'no_good_index_used_count')

      self.no_good_index_used_count = attributes[:'no_good_index_used_count'] if attributes[:'no_good_index_used_count']

      self.cpu_latency_in_ps = attributes[:'cpuLatencyInPs'] if attributes[:'cpuLatencyInPs']

      raise 'You cannot provide both :cpuLatencyInPs and :cpu_latency_in_ps' if attributes.key?(:'cpuLatencyInPs') && attributes.key?(:'cpu_latency_in_ps')

      self.cpu_latency_in_ps = attributes[:'cpu_latency_in_ps'] if attributes[:'cpu_latency_in_ps']

      self.max_controlled_memory_in_bytes = attributes[:'maxControlledMemoryInBytes'] if attributes[:'maxControlledMemoryInBytes']

      raise 'You cannot provide both :maxControlledMemoryInBytes and :max_controlled_memory_in_bytes' if attributes.key?(:'maxControlledMemoryInBytes') && attributes.key?(:'max_controlled_memory_in_bytes')

      self.max_controlled_memory_in_bytes = attributes[:'max_controlled_memory_in_bytes'] if attributes[:'max_controlled_memory_in_bytes']

      self.max_total_memory_in_bytes = attributes[:'maxTotalMemoryInBytes'] if attributes[:'maxTotalMemoryInBytes']

      raise 'You cannot provide both :maxTotalMemoryInBytes and :max_total_memory_in_bytes' if attributes.key?(:'maxTotalMemoryInBytes') && attributes.key?(:'max_total_memory_in_bytes')

      self.max_total_memory_in_bytes = attributes[:'max_total_memory_in_bytes'] if attributes[:'max_total_memory_in_bytes']

      self.exec_count_secondary = attributes[:'execCountSecondary'] if attributes[:'execCountSecondary']

      raise 'You cannot provide both :execCountSecondary and :exec_count_secondary' if attributes.key?(:'execCountSecondary') && attributes.key?(:'exec_count_secondary')

      self.exec_count_secondary = attributes[:'exec_count_secondary'] if attributes[:'exec_count_secondary']

      self.time_first_seen = attributes[:'timeFirstSeen'] if attributes[:'timeFirstSeen']

      raise 'You cannot provide both :timeFirstSeen and :time_first_seen' if attributes.key?(:'timeFirstSeen') && attributes.key?(:'time_first_seen')

      self.time_first_seen = attributes[:'time_first_seen'] if attributes[:'time_first_seen']

      self.time_last_seen = attributes[:'timeLastSeen'] if attributes[:'timeLastSeen']

      raise 'You cannot provide both :timeLastSeen and :time_last_seen' if attributes.key?(:'timeLastSeen') && attributes.key?(:'time_last_seen')

      self.time_last_seen = attributes[:'time_last_seen'] if attributes[:'time_last_seen']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        digest == other.digest &&
        time_collected == other.time_collected &&
        command_type == other.command_type &&
        total_rows == other.total_rows &&
        perf_schema_used_percent == other.perf_schema_used_percent &&
        schema_name == other.schema_name &&
        exec_count == other.exec_count &&
        total_latency_in_ps == other.total_latency_in_ps &&
        lock_latency_in_ps == other.lock_latency_in_ps &&
        err_count == other.err_count &&
        warn_count == other.warn_count &&
        rows_affected == other.rows_affected &&
        rows_sent == other.rows_sent &&
        rows_examined == other.rows_examined &&
        tmp_disk_tables == other.tmp_disk_tables &&
        tmp_tables == other.tmp_tables &&
        select_full_join == other.select_full_join &&
        select_full_range_join == other.select_full_range_join &&
        select_range == other.select_range &&
        select_range_check == other.select_range_check &&
        select_scan == other.select_scan &&
        sort_merge_passes == other.sort_merge_passes &&
        sort_range == other.sort_range &&
        rows_sorted == other.rows_sorted &&
        sort_scan == other.sort_scan &&
        no_index_used_count == other.no_index_used_count &&
        no_good_index_used_count == other.no_good_index_used_count &&
        cpu_latency_in_ps == other.cpu_latency_in_ps &&
        max_controlled_memory_in_bytes == other.max_controlled_memory_in_bytes &&
        max_total_memory_in_bytes == other.max_total_memory_in_bytes &&
        exec_count_secondary == other.exec_count_secondary &&
        time_first_seen == other.time_first_seen &&
        time_last_seen == other.time_last_seen
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [digest, time_collected, command_type, total_rows, perf_schema_used_percent, schema_name, exec_count, total_latency_in_ps, lock_latency_in_ps, err_count, warn_count, rows_affected, rows_sent, rows_examined, tmp_disk_tables, tmp_tables, select_full_join, select_full_range_join, select_range, select_range_check, select_scan, sort_merge_passes, sort_range, rows_sorted, sort_scan, no_index_used_count, no_good_index_used_count, cpu_latency_in_ps, max_controlled_memory_in_bytes, max_total_memory_in_bytes, exec_count_secondary, time_first_seen, time_last_seen].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
