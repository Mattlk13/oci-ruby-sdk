# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20201101
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # The summary of the Optimizer Statistics Collection operation.
  class DatabaseManagement::Models::OptimizerStatisticsCollectionOperationSummary
    STATUS_ENUM = [
      STATUS_IN_PROGRESS = 'IN_PROGRESS'.freeze,
      STATUS_COMPLETED = 'COMPLETED'.freeze,
      STATUS_FAILED = 'FAILED'.freeze,
      STATUS_TIMED_OUT = 'TIMED_OUT'.freeze,
      STATUS_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # **[Required]** The ID of the operation.
    # @return [Integer]
    attr_accessor :id

    # **[Required]** The name of the operation.
    # @return [String]
    attr_accessor :operation_name

    # **[Required]** The target object type such as Table, Index, and Partition.
    # @return [String]
    attr_accessor :target

    # **[Required]** The name of the job.
    # @return [String]
    attr_accessor :job_name

    # **[Required]** The status of the operation such as Completed, and Failed.
    # @return [String]
    attr_reader :status

    # **[Required]** The start time of the operation.
    # @return [String]
    attr_accessor :start_time

    # **[Required]** The end time of the operation.
    # @return [String]
    attr_accessor :end_time

    # **[Required]** The time it takes to complete the operation (in seconds).
    # @return [Float]
    attr_accessor :duration_in_seconds

    # The number of objects for which statistics collection is completed.
    # @return [Integer]
    attr_accessor :completed_count

    # The number of objects for which statistics collection is in progress.
    # @return [Integer]
    attr_accessor :in_progress_count

    # The number of objects for which statistics collection failed.
    # @return [Integer]
    attr_accessor :failed_count

    # The number of objects for which statistics collection timed out.
    # @return [Integer]
    attr_accessor :timed_out_count

    # The total number of objects for which statistics is collected. This number is the sum of all the objects
    # with various statuses: completed, inProgress, failed, and timedOut.
    #
    # @return [Integer]
    attr_accessor :total_objects_count

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'id': :'id',
        'operation_name': :'operationName',
        'target': :'target',
        'job_name': :'jobName',
        'status': :'status',
        'start_time': :'startTime',
        'end_time': :'endTime',
        'duration_in_seconds': :'durationInSeconds',
        'completed_count': :'completedCount',
        'in_progress_count': :'inProgressCount',
        'failed_count': :'failedCount',
        'timed_out_count': :'timedOutCount',
        'total_objects_count': :'totalObjectsCount'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'id': :'Integer',
        'operation_name': :'String',
        'target': :'String',
        'job_name': :'String',
        'status': :'String',
        'start_time': :'String',
        'end_time': :'String',
        'duration_in_seconds': :'Float',
        'completed_count': :'Integer',
        'in_progress_count': :'Integer',
        'failed_count': :'Integer',
        'timed_out_count': :'Integer',
        'total_objects_count': :'Integer'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [Integer] :id The value to assign to the {#id} property
    # @option attributes [String] :operation_name The value to assign to the {#operation_name} property
    # @option attributes [String] :target The value to assign to the {#target} property
    # @option attributes [String] :job_name The value to assign to the {#job_name} property
    # @option attributes [String] :status The value to assign to the {#status} property
    # @option attributes [String] :start_time The value to assign to the {#start_time} property
    # @option attributes [String] :end_time The value to assign to the {#end_time} property
    # @option attributes [Float] :duration_in_seconds The value to assign to the {#duration_in_seconds} property
    # @option attributes [Integer] :completed_count The value to assign to the {#completed_count} property
    # @option attributes [Integer] :in_progress_count The value to assign to the {#in_progress_count} property
    # @option attributes [Integer] :failed_count The value to assign to the {#failed_count} property
    # @option attributes [Integer] :timed_out_count The value to assign to the {#timed_out_count} property
    # @option attributes [Integer] :total_objects_count The value to assign to the {#total_objects_count} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.id = attributes[:'id'] if attributes[:'id']

      self.operation_name = attributes[:'operationName'] if attributes[:'operationName']

      raise 'You cannot provide both :operationName and :operation_name' if attributes.key?(:'operationName') && attributes.key?(:'operation_name')

      self.operation_name = attributes[:'operation_name'] if attributes[:'operation_name']

      self.target = attributes[:'target'] if attributes[:'target']

      self.job_name = attributes[:'jobName'] if attributes[:'jobName']

      raise 'You cannot provide both :jobName and :job_name' if attributes.key?(:'jobName') && attributes.key?(:'job_name')

      self.job_name = attributes[:'job_name'] if attributes[:'job_name']

      self.status = attributes[:'status'] if attributes[:'status']

      self.start_time = attributes[:'startTime'] if attributes[:'startTime']

      raise 'You cannot provide both :startTime and :start_time' if attributes.key?(:'startTime') && attributes.key?(:'start_time')

      self.start_time = attributes[:'start_time'] if attributes[:'start_time']

      self.end_time = attributes[:'endTime'] if attributes[:'endTime']

      raise 'You cannot provide both :endTime and :end_time' if attributes.key?(:'endTime') && attributes.key?(:'end_time')

      self.end_time = attributes[:'end_time'] if attributes[:'end_time']

      self.duration_in_seconds = attributes[:'durationInSeconds'] if attributes[:'durationInSeconds']

      raise 'You cannot provide both :durationInSeconds and :duration_in_seconds' if attributes.key?(:'durationInSeconds') && attributes.key?(:'duration_in_seconds')

      self.duration_in_seconds = attributes[:'duration_in_seconds'] if attributes[:'duration_in_seconds']

      self.completed_count = attributes[:'completedCount'] if attributes[:'completedCount']

      raise 'You cannot provide both :completedCount and :completed_count' if attributes.key?(:'completedCount') && attributes.key?(:'completed_count')

      self.completed_count = attributes[:'completed_count'] if attributes[:'completed_count']

      self.in_progress_count = attributes[:'inProgressCount'] if attributes[:'inProgressCount']

      raise 'You cannot provide both :inProgressCount and :in_progress_count' if attributes.key?(:'inProgressCount') && attributes.key?(:'in_progress_count')

      self.in_progress_count = attributes[:'in_progress_count'] if attributes[:'in_progress_count']

      self.failed_count = attributes[:'failedCount'] if attributes[:'failedCount']

      raise 'You cannot provide both :failedCount and :failed_count' if attributes.key?(:'failedCount') && attributes.key?(:'failed_count')

      self.failed_count = attributes[:'failed_count'] if attributes[:'failed_count']

      self.timed_out_count = attributes[:'timedOutCount'] if attributes[:'timedOutCount']

      raise 'You cannot provide both :timedOutCount and :timed_out_count' if attributes.key?(:'timedOutCount') && attributes.key?(:'timed_out_count')

      self.timed_out_count = attributes[:'timed_out_count'] if attributes[:'timed_out_count']

      self.total_objects_count = attributes[:'totalObjectsCount'] if attributes[:'totalObjectsCount']

      raise 'You cannot provide both :totalObjectsCount and :total_objects_count' if attributes.key?(:'totalObjectsCount') && attributes.key?(:'total_objects_count')

      self.total_objects_count = attributes[:'total_objects_count'] if attributes[:'total_objects_count']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] status Object to be assigned
    def status=(status)
      # rubocop:disable Style/ConditionalAssignment
      if status && !STATUS_ENUM.include?(status)
        OCI.logger.debug("Unknown value for 'status' [" + status + "]. Mapping to 'STATUS_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @status = STATUS_UNKNOWN_ENUM_VALUE
      else
        @status = status
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        id == other.id &&
        operation_name == other.operation_name &&
        target == other.target &&
        job_name == other.job_name &&
        status == other.status &&
        start_time == other.start_time &&
        end_time == other.end_time &&
        duration_in_seconds == other.duration_in_seconds &&
        completed_count == other.completed_count &&
        in_progress_count == other.in_progress_count &&
        failed_count == other.failed_count &&
        timed_out_count == other.timed_out_count &&
        total_objects_count == other.total_objects_count
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [id, operation_name, target, job_name, status, start_time, end_time, duration_in_seconds, completed_count, in_progress_count, failed_count, timed_out_count, total_objects_count].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
