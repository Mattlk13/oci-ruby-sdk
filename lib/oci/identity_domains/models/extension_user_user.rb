# Copyright (c) 2016, 2025, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: v1
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Oracle Identity Cloud Service User
  class IdentityDomains::Models::ExtensionUserUser
    STATUS_ENUM = [
      STATUS_PENDING_VERIFICATION = 'pendingVerification'.freeze,
      STATUS_VERIFIED = 'verified'.freeze,
      STATUS_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    PROVIDER_ENUM = [
      PROVIDER_FACEBOOK = 'facebook'.freeze,
      PROVIDER_GOOGLE = 'google'.freeze,
      PROVIDER_IDCS = 'IDCS'.freeze,
      PROVIDER_TWITTER = 'twitter'.freeze,
      PROVIDER_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    PREFERRED_UI_LANDING_PAGE_ENUM = [
      PREFERRED_UI_LANDING_PAGE_MY_APPS = 'MyApps'.freeze,
      PREFERRED_UI_LANDING_PAGE_MY_PROFILE = 'MyProfile'.freeze,
      PREFERRED_UI_LANDING_PAGE_OCI_CONSOLE = 'OciConsole'.freeze,
      PREFERRED_UI_LANDING_PAGE_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    CREATION_MECHANISM_ENUM = [
      CREATION_MECHANISM_BULK = 'bulk'.freeze,
      CREATION_MECHANISM_API = 'api'.freeze,
      CREATION_MECHANISM_ADSYNC = 'adsync'.freeze,
      CREATION_MECHANISM_IDCSUI = 'idcsui'.freeze,
      CREATION_MECHANISM_IMPORT = 'import'.freeze,
      CREATION_MECHANISM_AUTHSYNC = 'authsync'.freeze,
      CREATION_MECHANISM_SELFREG = 'selfreg'.freeze,
      CREATION_MECHANISM_SAMLJIT = 'samljit'.freeze,
      CREATION_MECHANISM_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # A Boolean value indicating whether or not the user is federated.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsCsvAttributeName: Federated
    #  - idcsCsvAttributeNameMappings: [[columnHeaderName:Federated]]
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readWrite
    #  - idcsRequiresWriteForAccessFlows: true
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :is_federated_user

    # A Boolean value indicating whether or not authentication request by this user should be delegated to a remote app. This value should be true only when the User was originally synced from an app which is enabled for delegated authentication
    #
    # **Added In:** 17.4.6
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: immutable
    #  - required: false
    #  - returned: never
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :is_authentication_delegated

    # A supplemental status indicating the reason why a user is disabled
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :status

    # Registration provider
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: immutable
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :provider

    # User's preferred landing page following login, logout and reset password.
    #
    # **Added In:** 2302092332
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :preferred_ui_landing_page

    # User creation mechanism
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsCsvAttributeNameMappings: [[defaultValue:import]]
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: immutable
    #  - idcsRequiresWriteForAccessFlows: true
    #  - required: false
    #  - returned: request
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :creation_mechanism

    # Specifies date time when a User's group membership was last modified.
    #
    # **Added In:** 2304270343
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - multiValued: false
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: dateTime
    #  - uniqueness: none
    # @return [String]
    attr_accessor :group_membership_last_modified

    # A Boolean value indicating whether or not to hide the getting started page
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :do_not_show_getting_started

    # A Boolean value indicating whether or not to send email notification after creating the user. This attribute is not used in update/replace operations.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsCsvAttributeNameMappings: [[columnHeaderName:ByPass Notification]]
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: immutable
    #  - idcsRequiresWriteForAccessFlows: true
    #  - required: false
    #  - returned: never
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :bypass_notification

    # A Boolean value indicating whether or not a user is enrolled for account recovery
    #
    # **Added In:** 19.1.4
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :is_account_recovery_enrolled

    # Boolean value to prompt user to setup account recovery during login.
    #
    # **Added In:** 19.1.4
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: request
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :account_recovery_required

    # A Boolean value indicating whether to bypass notification and return user token to be used by an external client to control the user flow.
    #
    # **Added In:** 18.4.2
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: immutable
    #  - required: false
    #  - returned: never
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :user_flow_controlled_by_external_client

    # A Boolean value indicating whether or not group membership is normalized for this user.
    #
    # **Deprecated Since: 19.3.3**
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: immutable
    #  - required: false
    #  - returned: never
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :is_group_membership_normalized

    # A Boolean value Indicates whether this User's group membership has been sync'ed from Group.members to UsersGroups.
    #
    # **Added In:** 19.3.3
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: immutable
    #  - required: false
    #  - returned: never
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :is_group_membership_synced_to_users_groups

    # Specifies the EmailTemplate to be used when sending notification to the user this request is for. If specified, it overrides the default EmailTemplate for this event.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: writeOnly
    #  - required: false
    #  - returned: never
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :notification_email_template_id

    # Indicates if User is a Service User
    #
    # **Added In:** 2306131901
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsCsvAttributeName: Service User
    #  - idcsCsvAttributeNameMappings: [[columnHeaderName:Service User]]
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: immutable
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :service_user

    # A list of Support Accounts corresponding to user.
    #
    # **Added In:** 2103141444
    #
    # **SCIM++ Properties:**
    #  - idcsCompositeKey: [value]
    #  - idcsSearchable: true
    #  - multiValued: true
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: complex
    #  - uniqueness: none
    # @return [Array<OCI::IdentityDomains::Models::UserExtSupportAccounts>]
    attr_accessor :support_accounts

    # Description:
    #
    # **Added In:** 19.2.1
    #
    # **SCIM++ Properties:**
    #  - idcsCompositeKey: [value, idcsAppRoleId]
    #  - idcsSearchable: true
    #  - multiValued: true
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: complex
    #
    # @return [Array<OCI::IdentityDomains::Models::UserExtIdcsAppRolesLimitedToGroups>]
    attr_accessor :idcs_app_roles_limited_to_groups

    # @return [OCI::IdentityDomains::Models::UserExtUserToken]
    attr_accessor :user_token

    # @return [OCI::IdentityDomains::Models::UserExtSyncedFromApp]
    attr_accessor :synced_from_app

    # @return [OCI::IdentityDomains::Models::UserExtApplicableAuthenticationTargetApp]
    attr_accessor :applicable_authentication_target_app

    # @return [OCI::IdentityDomains::Models::UserExtDelegatedAuthenticationTargetApp]
    attr_accessor :delegated_authentication_target_app

    # Accounts assigned to this User. Each value of this attribute refers to an app-specific identity that is owned by this User. Therefore, this attribute is a convenience that allows one to see on each User the Apps to which that User has access.
    #
    # **SCIM++ Properties:**
    #  - idcsPii: true
    #  - idcsSearchable: true
    #  - multiValued: true
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: complex
    #  - uniqueness: none
    # @return [Array<OCI::IdentityDomains::Models::UserExtAccounts>]
    attr_accessor :accounts

    # Grants to this User. Each value of this attribute refers to a Grant to this User of some App (and optionally of some entitlement). Therefore, this attribute is a convenience that allows one to see on each User all of the Grants to that User.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: true
    #  - multiValued: true
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: complex
    #  - uniqueness: none
    # @return [Array<OCI::IdentityDomains::Models::UserExtGrants>]
    attr_accessor :grants

    # A list of all AppRoles to which this User belongs directly, indirectly or implicitly. The User could belong directly because the User is a member of the AppRole, could belong indirectly because the User is a member of a Group that is a member of the AppRole, or could belong implicitly because the AppRole is public.
    #
    # **SCIM++ Properties:**
    #  - idcsCompositeKey: [value]
    #  - multiValued: true
    #  - mutability: readOnly
    #  - required: false
    #  - returned: request
    #  - type: complex
    #  - uniqueness: none
    # @return [Array<OCI::IdentityDomains::Models::UserExtAppRoles>]
    attr_accessor :app_roles

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'is_federated_user': :'isFederatedUser',
        'is_authentication_delegated': :'isAuthenticationDelegated',
        'status': :'status',
        'provider': :'provider',
        'preferred_ui_landing_page': :'preferredUiLandingPage',
        'creation_mechanism': :'creationMechanism',
        'group_membership_last_modified': :'groupMembershipLastModified',
        'do_not_show_getting_started': :'doNotShowGettingStarted',
        'bypass_notification': :'bypassNotification',
        'is_account_recovery_enrolled': :'isAccountRecoveryEnrolled',
        'account_recovery_required': :'accountRecoveryRequired',
        'user_flow_controlled_by_external_client': :'userFlowControlledByExternalClient',
        'is_group_membership_normalized': :'isGroupMembershipNormalized',
        'is_group_membership_synced_to_users_groups': :'isGroupMembershipSyncedToUsersGroups',
        'notification_email_template_id': :'notificationEmailTemplateId',
        'service_user': :'serviceUser',
        'support_accounts': :'supportAccounts',
        'idcs_app_roles_limited_to_groups': :'idcsAppRolesLimitedToGroups',
        'user_token': :'userToken',
        'synced_from_app': :'syncedFromApp',
        'applicable_authentication_target_app': :'applicableAuthenticationTargetApp',
        'delegated_authentication_target_app': :'delegatedAuthenticationTargetApp',
        'accounts': :'accounts',
        'grants': :'grants',
        'app_roles': :'appRoles'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'is_federated_user': :'BOOLEAN',
        'is_authentication_delegated': :'BOOLEAN',
        'status': :'String',
        'provider': :'String',
        'preferred_ui_landing_page': :'String',
        'creation_mechanism': :'String',
        'group_membership_last_modified': :'String',
        'do_not_show_getting_started': :'BOOLEAN',
        'bypass_notification': :'BOOLEAN',
        'is_account_recovery_enrolled': :'BOOLEAN',
        'account_recovery_required': :'BOOLEAN',
        'user_flow_controlled_by_external_client': :'BOOLEAN',
        'is_group_membership_normalized': :'BOOLEAN',
        'is_group_membership_synced_to_users_groups': :'BOOLEAN',
        'notification_email_template_id': :'String',
        'service_user': :'BOOLEAN',
        'support_accounts': :'Array<OCI::IdentityDomains::Models::UserExtSupportAccounts>',
        'idcs_app_roles_limited_to_groups': :'Array<OCI::IdentityDomains::Models::UserExtIdcsAppRolesLimitedToGroups>',
        'user_token': :'OCI::IdentityDomains::Models::UserExtUserToken',
        'synced_from_app': :'OCI::IdentityDomains::Models::UserExtSyncedFromApp',
        'applicable_authentication_target_app': :'OCI::IdentityDomains::Models::UserExtApplicableAuthenticationTargetApp',
        'delegated_authentication_target_app': :'OCI::IdentityDomains::Models::UserExtDelegatedAuthenticationTargetApp',
        'accounts': :'Array<OCI::IdentityDomains::Models::UserExtAccounts>',
        'grants': :'Array<OCI::IdentityDomains::Models::UserExtGrants>',
        'app_roles': :'Array<OCI::IdentityDomains::Models::UserExtAppRoles>'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [BOOLEAN] :is_federated_user The value to assign to the {#is_federated_user} property
    # @option attributes [BOOLEAN] :is_authentication_delegated The value to assign to the {#is_authentication_delegated} property
    # @option attributes [String] :status The value to assign to the {#status} property
    # @option attributes [String] :provider The value to assign to the {#provider} property
    # @option attributes [String] :preferred_ui_landing_page The value to assign to the {#preferred_ui_landing_page} property
    # @option attributes [String] :creation_mechanism The value to assign to the {#creation_mechanism} property
    # @option attributes [String] :group_membership_last_modified The value to assign to the {#group_membership_last_modified} property
    # @option attributes [BOOLEAN] :do_not_show_getting_started The value to assign to the {#do_not_show_getting_started} property
    # @option attributes [BOOLEAN] :bypass_notification The value to assign to the {#bypass_notification} property
    # @option attributes [BOOLEAN] :is_account_recovery_enrolled The value to assign to the {#is_account_recovery_enrolled} property
    # @option attributes [BOOLEAN] :account_recovery_required The value to assign to the {#account_recovery_required} property
    # @option attributes [BOOLEAN] :user_flow_controlled_by_external_client The value to assign to the {#user_flow_controlled_by_external_client} property
    # @option attributes [BOOLEAN] :is_group_membership_normalized The value to assign to the {#is_group_membership_normalized} property
    # @option attributes [BOOLEAN] :is_group_membership_synced_to_users_groups The value to assign to the {#is_group_membership_synced_to_users_groups} property
    # @option attributes [String] :notification_email_template_id The value to assign to the {#notification_email_template_id} property
    # @option attributes [BOOLEAN] :service_user The value to assign to the {#service_user} property
    # @option attributes [Array<OCI::IdentityDomains::Models::UserExtSupportAccounts>] :support_accounts The value to assign to the {#support_accounts} property
    # @option attributes [Array<OCI::IdentityDomains::Models::UserExtIdcsAppRolesLimitedToGroups>] :idcs_app_roles_limited_to_groups The value to assign to the {#idcs_app_roles_limited_to_groups} property
    # @option attributes [OCI::IdentityDomains::Models::UserExtUserToken] :user_token The value to assign to the {#user_token} property
    # @option attributes [OCI::IdentityDomains::Models::UserExtSyncedFromApp] :synced_from_app The value to assign to the {#synced_from_app} property
    # @option attributes [OCI::IdentityDomains::Models::UserExtApplicableAuthenticationTargetApp] :applicable_authentication_target_app The value to assign to the {#applicable_authentication_target_app} property
    # @option attributes [OCI::IdentityDomains::Models::UserExtDelegatedAuthenticationTargetApp] :delegated_authentication_target_app The value to assign to the {#delegated_authentication_target_app} property
    # @option attributes [Array<OCI::IdentityDomains::Models::UserExtAccounts>] :accounts The value to assign to the {#accounts} property
    # @option attributes [Array<OCI::IdentityDomains::Models::UserExtGrants>] :grants The value to assign to the {#grants} property
    # @option attributes [Array<OCI::IdentityDomains::Models::UserExtAppRoles>] :app_roles The value to assign to the {#app_roles} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.is_federated_user = attributes[:'isFederatedUser'] unless attributes[:'isFederatedUser'].nil?

      raise 'You cannot provide both :isFederatedUser and :is_federated_user' if attributes.key?(:'isFederatedUser') && attributes.key?(:'is_federated_user')

      self.is_federated_user = attributes[:'is_federated_user'] unless attributes[:'is_federated_user'].nil?

      self.is_authentication_delegated = attributes[:'isAuthenticationDelegated'] unless attributes[:'isAuthenticationDelegated'].nil?

      raise 'You cannot provide both :isAuthenticationDelegated and :is_authentication_delegated' if attributes.key?(:'isAuthenticationDelegated') && attributes.key?(:'is_authentication_delegated')

      self.is_authentication_delegated = attributes[:'is_authentication_delegated'] unless attributes[:'is_authentication_delegated'].nil?

      self.status = attributes[:'status'] if attributes[:'status']

      self.provider = attributes[:'provider'] if attributes[:'provider']

      self.preferred_ui_landing_page = attributes[:'preferredUiLandingPage'] if attributes[:'preferredUiLandingPage']

      raise 'You cannot provide both :preferredUiLandingPage and :preferred_ui_landing_page' if attributes.key?(:'preferredUiLandingPage') && attributes.key?(:'preferred_ui_landing_page')

      self.preferred_ui_landing_page = attributes[:'preferred_ui_landing_page'] if attributes[:'preferred_ui_landing_page']

      self.creation_mechanism = attributes[:'creationMechanism'] if attributes[:'creationMechanism']

      raise 'You cannot provide both :creationMechanism and :creation_mechanism' if attributes.key?(:'creationMechanism') && attributes.key?(:'creation_mechanism')

      self.creation_mechanism = attributes[:'creation_mechanism'] if attributes[:'creation_mechanism']

      self.group_membership_last_modified = attributes[:'groupMembershipLastModified'] if attributes[:'groupMembershipLastModified']

      raise 'You cannot provide both :groupMembershipLastModified and :group_membership_last_modified' if attributes.key?(:'groupMembershipLastModified') && attributes.key?(:'group_membership_last_modified')

      self.group_membership_last_modified = attributes[:'group_membership_last_modified'] if attributes[:'group_membership_last_modified']

      self.do_not_show_getting_started = attributes[:'doNotShowGettingStarted'] unless attributes[:'doNotShowGettingStarted'].nil?

      raise 'You cannot provide both :doNotShowGettingStarted and :do_not_show_getting_started' if attributes.key?(:'doNotShowGettingStarted') && attributes.key?(:'do_not_show_getting_started')

      self.do_not_show_getting_started = attributes[:'do_not_show_getting_started'] unless attributes[:'do_not_show_getting_started'].nil?

      self.bypass_notification = attributes[:'bypassNotification'] unless attributes[:'bypassNotification'].nil?

      raise 'You cannot provide both :bypassNotification and :bypass_notification' if attributes.key?(:'bypassNotification') && attributes.key?(:'bypass_notification')

      self.bypass_notification = attributes[:'bypass_notification'] unless attributes[:'bypass_notification'].nil?

      self.is_account_recovery_enrolled = attributes[:'isAccountRecoveryEnrolled'] unless attributes[:'isAccountRecoveryEnrolled'].nil?

      raise 'You cannot provide both :isAccountRecoveryEnrolled and :is_account_recovery_enrolled' if attributes.key?(:'isAccountRecoveryEnrolled') && attributes.key?(:'is_account_recovery_enrolled')

      self.is_account_recovery_enrolled = attributes[:'is_account_recovery_enrolled'] unless attributes[:'is_account_recovery_enrolled'].nil?

      self.account_recovery_required = attributes[:'accountRecoveryRequired'] unless attributes[:'accountRecoveryRequired'].nil?

      raise 'You cannot provide both :accountRecoveryRequired and :account_recovery_required' if attributes.key?(:'accountRecoveryRequired') && attributes.key?(:'account_recovery_required')

      self.account_recovery_required = attributes[:'account_recovery_required'] unless attributes[:'account_recovery_required'].nil?

      self.user_flow_controlled_by_external_client = attributes[:'userFlowControlledByExternalClient'] unless attributes[:'userFlowControlledByExternalClient'].nil?

      raise 'You cannot provide both :userFlowControlledByExternalClient and :user_flow_controlled_by_external_client' if attributes.key?(:'userFlowControlledByExternalClient') && attributes.key?(:'user_flow_controlled_by_external_client')

      self.user_flow_controlled_by_external_client = attributes[:'user_flow_controlled_by_external_client'] unless attributes[:'user_flow_controlled_by_external_client'].nil?

      self.is_group_membership_normalized = attributes[:'isGroupMembershipNormalized'] unless attributes[:'isGroupMembershipNormalized'].nil?

      raise 'You cannot provide both :isGroupMembershipNormalized and :is_group_membership_normalized' if attributes.key?(:'isGroupMembershipNormalized') && attributes.key?(:'is_group_membership_normalized')

      self.is_group_membership_normalized = attributes[:'is_group_membership_normalized'] unless attributes[:'is_group_membership_normalized'].nil?

      self.is_group_membership_synced_to_users_groups = attributes[:'isGroupMembershipSyncedToUsersGroups'] unless attributes[:'isGroupMembershipSyncedToUsersGroups'].nil?

      raise 'You cannot provide both :isGroupMembershipSyncedToUsersGroups and :is_group_membership_synced_to_users_groups' if attributes.key?(:'isGroupMembershipSyncedToUsersGroups') && attributes.key?(:'is_group_membership_synced_to_users_groups')

      self.is_group_membership_synced_to_users_groups = attributes[:'is_group_membership_synced_to_users_groups'] unless attributes[:'is_group_membership_synced_to_users_groups'].nil?

      self.notification_email_template_id = attributes[:'notificationEmailTemplateId'] if attributes[:'notificationEmailTemplateId']

      raise 'You cannot provide both :notificationEmailTemplateId and :notification_email_template_id' if attributes.key?(:'notificationEmailTemplateId') && attributes.key?(:'notification_email_template_id')

      self.notification_email_template_id = attributes[:'notification_email_template_id'] if attributes[:'notification_email_template_id']

      self.service_user = attributes[:'serviceUser'] unless attributes[:'serviceUser'].nil?

      raise 'You cannot provide both :serviceUser and :service_user' if attributes.key?(:'serviceUser') && attributes.key?(:'service_user')

      self.service_user = attributes[:'service_user'] unless attributes[:'service_user'].nil?

      self.support_accounts = attributes[:'supportAccounts'] if attributes[:'supportAccounts']

      raise 'You cannot provide both :supportAccounts and :support_accounts' if attributes.key?(:'supportAccounts') && attributes.key?(:'support_accounts')

      self.support_accounts = attributes[:'support_accounts'] if attributes[:'support_accounts']

      self.idcs_app_roles_limited_to_groups = attributes[:'idcsAppRolesLimitedToGroups'] if attributes[:'idcsAppRolesLimitedToGroups']

      raise 'You cannot provide both :idcsAppRolesLimitedToGroups and :idcs_app_roles_limited_to_groups' if attributes.key?(:'idcsAppRolesLimitedToGroups') && attributes.key?(:'idcs_app_roles_limited_to_groups')

      self.idcs_app_roles_limited_to_groups = attributes[:'idcs_app_roles_limited_to_groups'] if attributes[:'idcs_app_roles_limited_to_groups']

      self.user_token = attributes[:'userToken'] if attributes[:'userToken']

      raise 'You cannot provide both :userToken and :user_token' if attributes.key?(:'userToken') && attributes.key?(:'user_token')

      self.user_token = attributes[:'user_token'] if attributes[:'user_token']

      self.synced_from_app = attributes[:'syncedFromApp'] if attributes[:'syncedFromApp']

      raise 'You cannot provide both :syncedFromApp and :synced_from_app' if attributes.key?(:'syncedFromApp') && attributes.key?(:'synced_from_app')

      self.synced_from_app = attributes[:'synced_from_app'] if attributes[:'synced_from_app']

      self.applicable_authentication_target_app = attributes[:'applicableAuthenticationTargetApp'] if attributes[:'applicableAuthenticationTargetApp']

      raise 'You cannot provide both :applicableAuthenticationTargetApp and :applicable_authentication_target_app' if attributes.key?(:'applicableAuthenticationTargetApp') && attributes.key?(:'applicable_authentication_target_app')

      self.applicable_authentication_target_app = attributes[:'applicable_authentication_target_app'] if attributes[:'applicable_authentication_target_app']

      self.delegated_authentication_target_app = attributes[:'delegatedAuthenticationTargetApp'] if attributes[:'delegatedAuthenticationTargetApp']

      raise 'You cannot provide both :delegatedAuthenticationTargetApp and :delegated_authentication_target_app' if attributes.key?(:'delegatedAuthenticationTargetApp') && attributes.key?(:'delegated_authentication_target_app')

      self.delegated_authentication_target_app = attributes[:'delegated_authentication_target_app'] if attributes[:'delegated_authentication_target_app']

      self.accounts = attributes[:'accounts'] if attributes[:'accounts']

      self.grants = attributes[:'grants'] if attributes[:'grants']

      self.app_roles = attributes[:'appRoles'] if attributes[:'appRoles']

      raise 'You cannot provide both :appRoles and :app_roles' if attributes.key?(:'appRoles') && attributes.key?(:'app_roles')

      self.app_roles = attributes[:'app_roles'] if attributes[:'app_roles']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] status Object to be assigned
    def status=(status)
      # rubocop:disable Style/ConditionalAssignment
      if status && !STATUS_ENUM.include?(status)
        OCI.logger.debug("Unknown value for 'status' [" + status + "]. Mapping to 'STATUS_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @status = STATUS_UNKNOWN_ENUM_VALUE
      else
        @status = status
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] provider Object to be assigned
    def provider=(provider)
      # rubocop:disable Style/ConditionalAssignment
      if provider && !PROVIDER_ENUM.include?(provider)
        OCI.logger.debug("Unknown value for 'provider' [" + provider + "]. Mapping to 'PROVIDER_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @provider = PROVIDER_UNKNOWN_ENUM_VALUE
      else
        @provider = provider
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] preferred_ui_landing_page Object to be assigned
    def preferred_ui_landing_page=(preferred_ui_landing_page)
      # rubocop:disable Style/ConditionalAssignment
      if preferred_ui_landing_page && !PREFERRED_UI_LANDING_PAGE_ENUM.include?(preferred_ui_landing_page)
        OCI.logger.debug("Unknown value for 'preferred_ui_landing_page' [" + preferred_ui_landing_page + "]. Mapping to 'PREFERRED_UI_LANDING_PAGE_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @preferred_ui_landing_page = PREFERRED_UI_LANDING_PAGE_UNKNOWN_ENUM_VALUE
      else
        @preferred_ui_landing_page = preferred_ui_landing_page
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] creation_mechanism Object to be assigned
    def creation_mechanism=(creation_mechanism)
      # rubocop:disable Style/ConditionalAssignment
      if creation_mechanism && !CREATION_MECHANISM_ENUM.include?(creation_mechanism)
        OCI.logger.debug("Unknown value for 'creation_mechanism' [" + creation_mechanism + "]. Mapping to 'CREATION_MECHANISM_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @creation_mechanism = CREATION_MECHANISM_UNKNOWN_ENUM_VALUE
      else
        @creation_mechanism = creation_mechanism
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        is_federated_user == other.is_federated_user &&
        is_authentication_delegated == other.is_authentication_delegated &&
        status == other.status &&
        provider == other.provider &&
        preferred_ui_landing_page == other.preferred_ui_landing_page &&
        creation_mechanism == other.creation_mechanism &&
        group_membership_last_modified == other.group_membership_last_modified &&
        do_not_show_getting_started == other.do_not_show_getting_started &&
        bypass_notification == other.bypass_notification &&
        is_account_recovery_enrolled == other.is_account_recovery_enrolled &&
        account_recovery_required == other.account_recovery_required &&
        user_flow_controlled_by_external_client == other.user_flow_controlled_by_external_client &&
        is_group_membership_normalized == other.is_group_membership_normalized &&
        is_group_membership_synced_to_users_groups == other.is_group_membership_synced_to_users_groups &&
        notification_email_template_id == other.notification_email_template_id &&
        service_user == other.service_user &&
        support_accounts == other.support_accounts &&
        idcs_app_roles_limited_to_groups == other.idcs_app_roles_limited_to_groups &&
        user_token == other.user_token &&
        synced_from_app == other.synced_from_app &&
        applicable_authentication_target_app == other.applicable_authentication_target_app &&
        delegated_authentication_target_app == other.delegated_authentication_target_app &&
        accounts == other.accounts &&
        grants == other.grants &&
        app_roles == other.app_roles
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [is_federated_user, is_authentication_delegated, status, provider, preferred_ui_landing_page, creation_mechanism, group_membership_last_modified, do_not_show_getting_started, bypass_notification, is_account_recovery_enrolled, account_recovery_required, user_flow_controlled_by_external_client, is_group_membership_normalized, is_group_membership_synced_to_users_groups, notification_email_template_id, service_user, support_accounts, idcs_app_roles_limited_to_groups, user_token, synced_from_app, applicable_authentication_target_app, delegated_authentication_target_app, accounts, grants, app_roles].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
