# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: v1
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # This extension defines attributes related to the Service Providers configuration.
  class IdentityDomains::Models::AppExtensionSamlServiceProviderApp
    ENCRYPTION_ALGORITHM_ENUM = [
      ENCRYPTION_ALGORITHM_3_DES = '3DES'.freeze,
      ENCRYPTION_ALGORITHM_AES_128 = 'AES-128'.freeze,
      ENCRYPTION_ALGORITHM_AES_256 = 'AES-256'.freeze,
      ENCRYPTION_ALGORITHM_AES_192 = 'AES-192'.freeze,
      ENCRYPTION_ALGORITHM_AES_128_GCM = 'AES-128-GCM'.freeze,
      ENCRYPTION_ALGORITHM_AES_256_GCM = 'AES-256-GCM'.freeze,
      ENCRYPTION_ALGORITHM_AES_192_GCM = 'AES-192-GCM'.freeze,
      ENCRYPTION_ALGORITHM_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    KEY_ENCRYPTION_ALGORITHM_ENUM = [
      KEY_ENCRYPTION_ALGORITHM_RSA_V1_5 = 'RSA-v1.5'.freeze,
      KEY_ENCRYPTION_ALGORITHM_RSA_OAEP = 'RSA-OAEP'.freeze,
      KEY_ENCRYPTION_ALGORITHM_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    SIGN_RESPONSE_OR_ASSERTION_ENUM = [
      SIGN_RESPONSE_OR_ASSERTION_ASSERTION = 'Assertion'.freeze,
      SIGN_RESPONSE_OR_ASSERTION_RESPONSE = 'Response'.freeze,
      SIGN_RESPONSE_OR_ASSERTION_ASSERTION_AND_RESPONSE = 'AssertionAndResponse'.freeze,
      SIGN_RESPONSE_OR_ASSERTION_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    LOGOUT_BINDING_ENUM = [
      LOGOUT_BINDING_REDIRECT = 'Redirect'.freeze,
      LOGOUT_BINDING_POST = 'Post'.freeze,
      LOGOUT_BINDING_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    SIGNATURE_HASH_ALGORITHM_ENUM = [
      SIGNATURE_HASH_ALGORITHM_SHA_1 = 'SHA-1'.freeze,
      SIGNATURE_HASH_ALGORITHM_SHA_256 = 'SHA-256'.freeze,
      SIGNATURE_HASH_ALGORITHM_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    FEDERATION_PROTOCOL_ENUM = [
      FEDERATION_PROTOCOL_SAML2_0 = 'SAML2.0'.freeze,
      FEDERATION_PROTOCOL_WS_FED1_1 = 'WS-Fed1.1'.freeze,
      FEDERATION_PROTOCOL_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # This attribute represents the metadata of a Security Provider in the Security Assertion Markup Language protocol.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :metadata

    # The ID of the Provider. This value corresponds to the entityID from the Service Provider metadata.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :partner_provider_id

    # The pattern of the Provider. This value corresponds to the entityID from the Service Provider metadata.
    #
    # **Added In:** 2202230830
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: request
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :partner_provider_pattern

    # The alternate Provider ID to be used as the Oracle Identity Cloud Service providerID (instead of the one in SamlSettings) when interacting with this SP.
    #
    # **Added In:** 19.2.1
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readOnly
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :tenant_provider_id

    # This attribute represents the Succinct ID.
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: server
    # @return [String]
    attr_accessor :succinct_id

    # The attribute represents the URL to which the SAML Assertions will be sent by the SAML IdP.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :assertion_consumer_url

    # The URL to which the partner sends the logout request.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :logout_request_url

    # The URL to which the partner sends the logout response.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :logout_response_url

    # This can be any string, but there are a set of standard nameIdFormats. If a nameIdFormat other than the standard list is chosen, it will be considered a custom nameidformat. The standard nameidformats include: saml-x509, saml-emailaddress, saml-windowsnamequalifier, saml-kerberos, saml-persistent, saml-transient, saml-unspecified, saml-none, and saml-persistent-opaque.
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :name_id_format

    # This attribute represents the signing certificate that an App uses to verify the signed authentication request.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :signing_certificate

    # This attribute represents the encryption certificate that an App uses to encrypt the Security Assertion Markup Language (SAML) assertion.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :encryption_certificate

    # This attribute indicates the encryption algorithm used to encrypt the SAML assertion.
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :encryption_algorithm

    # This attribute indicates the key encryption algorithm.
    #
    # **Added In:** 18.4.2
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :key_encryption_algorithm

    # If true, indicates that the system must encrypt the Security Assertion Markup Language (SAML) assertion.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :encrypt_assertion

    # Indicates which part of the response should be signed.  A value of \\\"Assertion\\\" indicates that the Assertion should be signed.  A value of \\\"Response\\\" indicates that the SSO Response should be signed. A value of \\\"AssertionAndResponse\\\" indicates that both the Assertion and the SSO Response should be signed.
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :sign_response_or_assertion

    # If true, then the signing certificate is included in the signature.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :include_signing_cert_in_signature

    # This attribute represents the HTTP binding that would be used while logout.
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :logout_binding

    # If true, then the SAML Service supports logout for this App.
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :logout_enabled

    # This attribute represents the algorithm used to hash the signature.
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :signature_hash_algorithm

    # Specifies the preferred federation protocol (SAML2.0 or WS-Fed1.1).
    #
    # **Added In:** 18.2.6
    #
    # **SCIM++ Properties:**
    #  - caseExact: true
    #  - idcsDefaultValue: SAML2.0
    #  - idcsSearchable: true
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_reader :federation_protocol

    # **Deprecated Since: 18.2.2**
    #
    # **SCIM++ Properties:**
    # - caseExact: false
    # - idcsSearchable: true
    # - idcsValuePersistedInOtherAttribute: true
    # - multiValued: false
    # - mutability: readWrite
    # - required: false
    # - returned: default
    # - type: string
    # - uniqueness: none
    # This property specifies which user attribute is used as the NameID value in the SAML assertion. This attribute can be constructed by using attributes from the Oracle Identity Cloud Service Core Users schema.
    # @return [String]
    attr_accessor :name_id_userstore_attribute

    # If enabled, then the SAML Service supports Hok for this App.
    #
    # **Added In:** 2101262133
    #
    # **SCIM++ Properties:**
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: boolean
    #  - uniqueness: none
    # @return [BOOLEAN]
    attr_accessor :hok_required

    # Hok Assertion Consumer Service Url
    #
    # **Added In:** 2101262133
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: string
    #  - uniqueness: none
    # @return [String]
    attr_accessor :hok_acs_url

    # Records the notification timestamp for the SP whose signing certificate is about to expire.
    #
    # **Added In:** 2302092332
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsSearchable: false
    #  - multiValued: false
    #  - mutability: readOnly
    #  - required: false
    #  - returned: default
    #  - type: dateTime
    #  - uniqueness: none
    # @return [String]
    attr_accessor :last_notification_sent_time

    # @return [OCI::IdentityDomains::Models::AppOutboundAssertionAttributes]
    attr_accessor :outbound_assertion_attributes

    # Each value of this attribute describes an attribute of User that will be sent in a Security Assertion Markup Language (SAML) assertion.
    #
    # **Deprecated Since: 18.2.2**
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsCompositeKey: [name]
    #  - idcsSearchable: false
    #  - idcsValuePersistedInOtherAttribute: true
    #  - multiValued: true
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: complex
    #  - uniqueness: none
    # @return [Array<OCI::IdentityDomains::Models::AppUserAssertionAttributes>]
    attr_accessor :user_assertion_attributes

    # Each value of this attribute describes an attribute of Group that will be sent in a Security Assertion Markup Language (SAML) assertion.
    #
    # **Deprecated Since: 18.2.2**
    #
    # **SCIM++ Properties:**
    #  - caseExact: false
    #  - idcsCompositeKey: [name]
    #  - idcsSearchable: false
    #  - idcsValuePersistedInOtherAttribute: true
    #  - multiValued: true
    #  - mutability: readWrite
    #  - required: false
    #  - returned: default
    #  - type: complex
    #  - uniqueness: none
    # @return [Array<OCI::IdentityDomains::Models::AppGroupAssertionAttributes>]
    attr_accessor :group_assertion_attributes

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'metadata': :'metadata',
        'partner_provider_id': :'partnerProviderId',
        'partner_provider_pattern': :'partnerProviderPattern',
        'tenant_provider_id': :'tenantProviderId',
        'succinct_id': :'succinctId',
        'assertion_consumer_url': :'assertionConsumerUrl',
        'logout_request_url': :'logoutRequestUrl',
        'logout_response_url': :'logoutResponseUrl',
        'name_id_format': :'nameIdFormat',
        'signing_certificate': :'signingCertificate',
        'encryption_certificate': :'encryptionCertificate',
        'encryption_algorithm': :'encryptionAlgorithm',
        'key_encryption_algorithm': :'keyEncryptionAlgorithm',
        'encrypt_assertion': :'encryptAssertion',
        'sign_response_or_assertion': :'signResponseOrAssertion',
        'include_signing_cert_in_signature': :'includeSigningCertInSignature',
        'logout_binding': :'logoutBinding',
        'logout_enabled': :'logoutEnabled',
        'signature_hash_algorithm': :'signatureHashAlgorithm',
        'federation_protocol': :'federationProtocol',
        'name_id_userstore_attribute': :'nameIdUserstoreAttribute',
        'hok_required': :'hokRequired',
        'hok_acs_url': :'hokAcsUrl',
        'last_notification_sent_time': :'lastNotificationSentTime',
        'outbound_assertion_attributes': :'outboundAssertionAttributes',
        'user_assertion_attributes': :'userAssertionAttributes',
        'group_assertion_attributes': :'groupAssertionAttributes'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'metadata': :'String',
        'partner_provider_id': :'String',
        'partner_provider_pattern': :'String',
        'tenant_provider_id': :'String',
        'succinct_id': :'String',
        'assertion_consumer_url': :'String',
        'logout_request_url': :'String',
        'logout_response_url': :'String',
        'name_id_format': :'String',
        'signing_certificate': :'String',
        'encryption_certificate': :'String',
        'encryption_algorithm': :'String',
        'key_encryption_algorithm': :'String',
        'encrypt_assertion': :'BOOLEAN',
        'sign_response_or_assertion': :'String',
        'include_signing_cert_in_signature': :'BOOLEAN',
        'logout_binding': :'String',
        'logout_enabled': :'BOOLEAN',
        'signature_hash_algorithm': :'String',
        'federation_protocol': :'String',
        'name_id_userstore_attribute': :'String',
        'hok_required': :'BOOLEAN',
        'hok_acs_url': :'String',
        'last_notification_sent_time': :'String',
        'outbound_assertion_attributes': :'OCI::IdentityDomains::Models::AppOutboundAssertionAttributes',
        'user_assertion_attributes': :'Array<OCI::IdentityDomains::Models::AppUserAssertionAttributes>',
        'group_assertion_attributes': :'Array<OCI::IdentityDomains::Models::AppGroupAssertionAttributes>'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :metadata The value to assign to the {#metadata} property
    # @option attributes [String] :partner_provider_id The value to assign to the {#partner_provider_id} property
    # @option attributes [String] :partner_provider_pattern The value to assign to the {#partner_provider_pattern} property
    # @option attributes [String] :tenant_provider_id The value to assign to the {#tenant_provider_id} property
    # @option attributes [String] :succinct_id The value to assign to the {#succinct_id} property
    # @option attributes [String] :assertion_consumer_url The value to assign to the {#assertion_consumer_url} property
    # @option attributes [String] :logout_request_url The value to assign to the {#logout_request_url} property
    # @option attributes [String] :logout_response_url The value to assign to the {#logout_response_url} property
    # @option attributes [String] :name_id_format The value to assign to the {#name_id_format} property
    # @option attributes [String] :signing_certificate The value to assign to the {#signing_certificate} property
    # @option attributes [String] :encryption_certificate The value to assign to the {#encryption_certificate} property
    # @option attributes [String] :encryption_algorithm The value to assign to the {#encryption_algorithm} property
    # @option attributes [String] :key_encryption_algorithm The value to assign to the {#key_encryption_algorithm} property
    # @option attributes [BOOLEAN] :encrypt_assertion The value to assign to the {#encrypt_assertion} property
    # @option attributes [String] :sign_response_or_assertion The value to assign to the {#sign_response_or_assertion} property
    # @option attributes [BOOLEAN] :include_signing_cert_in_signature The value to assign to the {#include_signing_cert_in_signature} property
    # @option attributes [String] :logout_binding The value to assign to the {#logout_binding} property
    # @option attributes [BOOLEAN] :logout_enabled The value to assign to the {#logout_enabled} property
    # @option attributes [String] :signature_hash_algorithm The value to assign to the {#signature_hash_algorithm} property
    # @option attributes [String] :federation_protocol The value to assign to the {#federation_protocol} property
    # @option attributes [String] :name_id_userstore_attribute The value to assign to the {#name_id_userstore_attribute} property
    # @option attributes [BOOLEAN] :hok_required The value to assign to the {#hok_required} property
    # @option attributes [String] :hok_acs_url The value to assign to the {#hok_acs_url} property
    # @option attributes [String] :last_notification_sent_time The value to assign to the {#last_notification_sent_time} property
    # @option attributes [OCI::IdentityDomains::Models::AppOutboundAssertionAttributes] :outbound_assertion_attributes The value to assign to the {#outbound_assertion_attributes} property
    # @option attributes [Array<OCI::IdentityDomains::Models::AppUserAssertionAttributes>] :user_assertion_attributes The value to assign to the {#user_assertion_attributes} property
    # @option attributes [Array<OCI::IdentityDomains::Models::AppGroupAssertionAttributes>] :group_assertion_attributes The value to assign to the {#group_assertion_attributes} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.metadata = attributes[:'metadata'] if attributes[:'metadata']

      self.partner_provider_id = attributes[:'partnerProviderId'] if attributes[:'partnerProviderId']

      raise 'You cannot provide both :partnerProviderId and :partner_provider_id' if attributes.key?(:'partnerProviderId') && attributes.key?(:'partner_provider_id')

      self.partner_provider_id = attributes[:'partner_provider_id'] if attributes[:'partner_provider_id']

      self.partner_provider_pattern = attributes[:'partnerProviderPattern'] if attributes[:'partnerProviderPattern']

      raise 'You cannot provide both :partnerProviderPattern and :partner_provider_pattern' if attributes.key?(:'partnerProviderPattern') && attributes.key?(:'partner_provider_pattern')

      self.partner_provider_pattern = attributes[:'partner_provider_pattern'] if attributes[:'partner_provider_pattern']

      self.tenant_provider_id = attributes[:'tenantProviderId'] if attributes[:'tenantProviderId']

      raise 'You cannot provide both :tenantProviderId and :tenant_provider_id' if attributes.key?(:'tenantProviderId') && attributes.key?(:'tenant_provider_id')

      self.tenant_provider_id = attributes[:'tenant_provider_id'] if attributes[:'tenant_provider_id']

      self.succinct_id = attributes[:'succinctId'] if attributes[:'succinctId']

      raise 'You cannot provide both :succinctId and :succinct_id' if attributes.key?(:'succinctId') && attributes.key?(:'succinct_id')

      self.succinct_id = attributes[:'succinct_id'] if attributes[:'succinct_id']

      self.assertion_consumer_url = attributes[:'assertionConsumerUrl'] if attributes[:'assertionConsumerUrl']

      raise 'You cannot provide both :assertionConsumerUrl and :assertion_consumer_url' if attributes.key?(:'assertionConsumerUrl') && attributes.key?(:'assertion_consumer_url')

      self.assertion_consumer_url = attributes[:'assertion_consumer_url'] if attributes[:'assertion_consumer_url']

      self.logout_request_url = attributes[:'logoutRequestUrl'] if attributes[:'logoutRequestUrl']

      raise 'You cannot provide both :logoutRequestUrl and :logout_request_url' if attributes.key?(:'logoutRequestUrl') && attributes.key?(:'logout_request_url')

      self.logout_request_url = attributes[:'logout_request_url'] if attributes[:'logout_request_url']

      self.logout_response_url = attributes[:'logoutResponseUrl'] if attributes[:'logoutResponseUrl']

      raise 'You cannot provide both :logoutResponseUrl and :logout_response_url' if attributes.key?(:'logoutResponseUrl') && attributes.key?(:'logout_response_url')

      self.logout_response_url = attributes[:'logout_response_url'] if attributes[:'logout_response_url']

      self.name_id_format = attributes[:'nameIdFormat'] if attributes[:'nameIdFormat']

      raise 'You cannot provide both :nameIdFormat and :name_id_format' if attributes.key?(:'nameIdFormat') && attributes.key?(:'name_id_format')

      self.name_id_format = attributes[:'name_id_format'] if attributes[:'name_id_format']

      self.signing_certificate = attributes[:'signingCertificate'] if attributes[:'signingCertificate']

      raise 'You cannot provide both :signingCertificate and :signing_certificate' if attributes.key?(:'signingCertificate') && attributes.key?(:'signing_certificate')

      self.signing_certificate = attributes[:'signing_certificate'] if attributes[:'signing_certificate']

      self.encryption_certificate = attributes[:'encryptionCertificate'] if attributes[:'encryptionCertificate']

      raise 'You cannot provide both :encryptionCertificate and :encryption_certificate' if attributes.key?(:'encryptionCertificate') && attributes.key?(:'encryption_certificate')

      self.encryption_certificate = attributes[:'encryption_certificate'] if attributes[:'encryption_certificate']

      self.encryption_algorithm = attributes[:'encryptionAlgorithm'] if attributes[:'encryptionAlgorithm']

      raise 'You cannot provide both :encryptionAlgorithm and :encryption_algorithm' if attributes.key?(:'encryptionAlgorithm') && attributes.key?(:'encryption_algorithm')

      self.encryption_algorithm = attributes[:'encryption_algorithm'] if attributes[:'encryption_algorithm']

      self.key_encryption_algorithm = attributes[:'keyEncryptionAlgorithm'] if attributes[:'keyEncryptionAlgorithm']

      raise 'You cannot provide both :keyEncryptionAlgorithm and :key_encryption_algorithm' if attributes.key?(:'keyEncryptionAlgorithm') && attributes.key?(:'key_encryption_algorithm')

      self.key_encryption_algorithm = attributes[:'key_encryption_algorithm'] if attributes[:'key_encryption_algorithm']

      self.encrypt_assertion = attributes[:'encryptAssertion'] unless attributes[:'encryptAssertion'].nil?

      raise 'You cannot provide both :encryptAssertion and :encrypt_assertion' if attributes.key?(:'encryptAssertion') && attributes.key?(:'encrypt_assertion')

      self.encrypt_assertion = attributes[:'encrypt_assertion'] unless attributes[:'encrypt_assertion'].nil?

      self.sign_response_or_assertion = attributes[:'signResponseOrAssertion'] if attributes[:'signResponseOrAssertion']

      raise 'You cannot provide both :signResponseOrAssertion and :sign_response_or_assertion' if attributes.key?(:'signResponseOrAssertion') && attributes.key?(:'sign_response_or_assertion')

      self.sign_response_or_assertion = attributes[:'sign_response_or_assertion'] if attributes[:'sign_response_or_assertion']

      self.include_signing_cert_in_signature = attributes[:'includeSigningCertInSignature'] unless attributes[:'includeSigningCertInSignature'].nil?

      raise 'You cannot provide both :includeSigningCertInSignature and :include_signing_cert_in_signature' if attributes.key?(:'includeSigningCertInSignature') && attributes.key?(:'include_signing_cert_in_signature')

      self.include_signing_cert_in_signature = attributes[:'include_signing_cert_in_signature'] unless attributes[:'include_signing_cert_in_signature'].nil?

      self.logout_binding = attributes[:'logoutBinding'] if attributes[:'logoutBinding']

      raise 'You cannot provide both :logoutBinding and :logout_binding' if attributes.key?(:'logoutBinding') && attributes.key?(:'logout_binding')

      self.logout_binding = attributes[:'logout_binding'] if attributes[:'logout_binding']

      self.logout_enabled = attributes[:'logoutEnabled'] unless attributes[:'logoutEnabled'].nil?

      raise 'You cannot provide both :logoutEnabled and :logout_enabled' if attributes.key?(:'logoutEnabled') && attributes.key?(:'logout_enabled')

      self.logout_enabled = attributes[:'logout_enabled'] unless attributes[:'logout_enabled'].nil?

      self.signature_hash_algorithm = attributes[:'signatureHashAlgorithm'] if attributes[:'signatureHashAlgorithm']

      raise 'You cannot provide both :signatureHashAlgorithm and :signature_hash_algorithm' if attributes.key?(:'signatureHashAlgorithm') && attributes.key?(:'signature_hash_algorithm')

      self.signature_hash_algorithm = attributes[:'signature_hash_algorithm'] if attributes[:'signature_hash_algorithm']

      self.federation_protocol = attributes[:'federationProtocol'] if attributes[:'federationProtocol']

      raise 'You cannot provide both :federationProtocol and :federation_protocol' if attributes.key?(:'federationProtocol') && attributes.key?(:'federation_protocol')

      self.federation_protocol = attributes[:'federation_protocol'] if attributes[:'federation_protocol']

      self.name_id_userstore_attribute = attributes[:'nameIdUserstoreAttribute'] if attributes[:'nameIdUserstoreAttribute']

      raise 'You cannot provide both :nameIdUserstoreAttribute and :name_id_userstore_attribute' if attributes.key?(:'nameIdUserstoreAttribute') && attributes.key?(:'name_id_userstore_attribute')

      self.name_id_userstore_attribute = attributes[:'name_id_userstore_attribute'] if attributes[:'name_id_userstore_attribute']

      self.hok_required = attributes[:'hokRequired'] unless attributes[:'hokRequired'].nil?

      raise 'You cannot provide both :hokRequired and :hok_required' if attributes.key?(:'hokRequired') && attributes.key?(:'hok_required')

      self.hok_required = attributes[:'hok_required'] unless attributes[:'hok_required'].nil?

      self.hok_acs_url = attributes[:'hokAcsUrl'] if attributes[:'hokAcsUrl']

      raise 'You cannot provide both :hokAcsUrl and :hok_acs_url' if attributes.key?(:'hokAcsUrl') && attributes.key?(:'hok_acs_url')

      self.hok_acs_url = attributes[:'hok_acs_url'] if attributes[:'hok_acs_url']

      self.last_notification_sent_time = attributes[:'lastNotificationSentTime'] if attributes[:'lastNotificationSentTime']

      raise 'You cannot provide both :lastNotificationSentTime and :last_notification_sent_time' if attributes.key?(:'lastNotificationSentTime') && attributes.key?(:'last_notification_sent_time')

      self.last_notification_sent_time = attributes[:'last_notification_sent_time'] if attributes[:'last_notification_sent_time']

      self.outbound_assertion_attributes = attributes[:'outboundAssertionAttributes'] if attributes[:'outboundAssertionAttributes']

      raise 'You cannot provide both :outboundAssertionAttributes and :outbound_assertion_attributes' if attributes.key?(:'outboundAssertionAttributes') && attributes.key?(:'outbound_assertion_attributes')

      self.outbound_assertion_attributes = attributes[:'outbound_assertion_attributes'] if attributes[:'outbound_assertion_attributes']

      self.user_assertion_attributes = attributes[:'userAssertionAttributes'] if attributes[:'userAssertionAttributes']

      raise 'You cannot provide both :userAssertionAttributes and :user_assertion_attributes' if attributes.key?(:'userAssertionAttributes') && attributes.key?(:'user_assertion_attributes')

      self.user_assertion_attributes = attributes[:'user_assertion_attributes'] if attributes[:'user_assertion_attributes']

      self.group_assertion_attributes = attributes[:'groupAssertionAttributes'] if attributes[:'groupAssertionAttributes']

      raise 'You cannot provide both :groupAssertionAttributes and :group_assertion_attributes' if attributes.key?(:'groupAssertionAttributes') && attributes.key?(:'group_assertion_attributes')

      self.group_assertion_attributes = attributes[:'group_assertion_attributes'] if attributes[:'group_assertion_attributes']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] encryption_algorithm Object to be assigned
    def encryption_algorithm=(encryption_algorithm)
      # rubocop:disable Style/ConditionalAssignment
      if encryption_algorithm && !ENCRYPTION_ALGORITHM_ENUM.include?(encryption_algorithm)
        OCI.logger.debug("Unknown value for 'encryption_algorithm' [" + encryption_algorithm + "]. Mapping to 'ENCRYPTION_ALGORITHM_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @encryption_algorithm = ENCRYPTION_ALGORITHM_UNKNOWN_ENUM_VALUE
      else
        @encryption_algorithm = encryption_algorithm
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] key_encryption_algorithm Object to be assigned
    def key_encryption_algorithm=(key_encryption_algorithm)
      # rubocop:disable Style/ConditionalAssignment
      if key_encryption_algorithm && !KEY_ENCRYPTION_ALGORITHM_ENUM.include?(key_encryption_algorithm)
        OCI.logger.debug("Unknown value for 'key_encryption_algorithm' [" + key_encryption_algorithm + "]. Mapping to 'KEY_ENCRYPTION_ALGORITHM_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @key_encryption_algorithm = KEY_ENCRYPTION_ALGORITHM_UNKNOWN_ENUM_VALUE
      else
        @key_encryption_algorithm = key_encryption_algorithm
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] sign_response_or_assertion Object to be assigned
    def sign_response_or_assertion=(sign_response_or_assertion)
      # rubocop:disable Style/ConditionalAssignment
      if sign_response_or_assertion && !SIGN_RESPONSE_OR_ASSERTION_ENUM.include?(sign_response_or_assertion)
        OCI.logger.debug("Unknown value for 'sign_response_or_assertion' [" + sign_response_or_assertion + "]. Mapping to 'SIGN_RESPONSE_OR_ASSERTION_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @sign_response_or_assertion = SIGN_RESPONSE_OR_ASSERTION_UNKNOWN_ENUM_VALUE
      else
        @sign_response_or_assertion = sign_response_or_assertion
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] logout_binding Object to be assigned
    def logout_binding=(logout_binding)
      # rubocop:disable Style/ConditionalAssignment
      if logout_binding && !LOGOUT_BINDING_ENUM.include?(logout_binding)
        OCI.logger.debug("Unknown value for 'logout_binding' [" + logout_binding + "]. Mapping to 'LOGOUT_BINDING_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @logout_binding = LOGOUT_BINDING_UNKNOWN_ENUM_VALUE
      else
        @logout_binding = logout_binding
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] signature_hash_algorithm Object to be assigned
    def signature_hash_algorithm=(signature_hash_algorithm)
      # rubocop:disable Style/ConditionalAssignment
      if signature_hash_algorithm && !SIGNATURE_HASH_ALGORITHM_ENUM.include?(signature_hash_algorithm)
        OCI.logger.debug("Unknown value for 'signature_hash_algorithm' [" + signature_hash_algorithm + "]. Mapping to 'SIGNATURE_HASH_ALGORITHM_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @signature_hash_algorithm = SIGNATURE_HASH_ALGORITHM_UNKNOWN_ENUM_VALUE
      else
        @signature_hash_algorithm = signature_hash_algorithm
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] federation_protocol Object to be assigned
    def federation_protocol=(federation_protocol)
      # rubocop:disable Style/ConditionalAssignment
      if federation_protocol && !FEDERATION_PROTOCOL_ENUM.include?(federation_protocol)
        OCI.logger.debug("Unknown value for 'federation_protocol' [" + federation_protocol + "]. Mapping to 'FEDERATION_PROTOCOL_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @federation_protocol = FEDERATION_PROTOCOL_UNKNOWN_ENUM_VALUE
      else
        @federation_protocol = federation_protocol
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        metadata == other.metadata &&
        partner_provider_id == other.partner_provider_id &&
        partner_provider_pattern == other.partner_provider_pattern &&
        tenant_provider_id == other.tenant_provider_id &&
        succinct_id == other.succinct_id &&
        assertion_consumer_url == other.assertion_consumer_url &&
        logout_request_url == other.logout_request_url &&
        logout_response_url == other.logout_response_url &&
        name_id_format == other.name_id_format &&
        signing_certificate == other.signing_certificate &&
        encryption_certificate == other.encryption_certificate &&
        encryption_algorithm == other.encryption_algorithm &&
        key_encryption_algorithm == other.key_encryption_algorithm &&
        encrypt_assertion == other.encrypt_assertion &&
        sign_response_or_assertion == other.sign_response_or_assertion &&
        include_signing_cert_in_signature == other.include_signing_cert_in_signature &&
        logout_binding == other.logout_binding &&
        logout_enabled == other.logout_enabled &&
        signature_hash_algorithm == other.signature_hash_algorithm &&
        federation_protocol == other.federation_protocol &&
        name_id_userstore_attribute == other.name_id_userstore_attribute &&
        hok_required == other.hok_required &&
        hok_acs_url == other.hok_acs_url &&
        last_notification_sent_time == other.last_notification_sent_time &&
        outbound_assertion_attributes == other.outbound_assertion_attributes &&
        user_assertion_attributes == other.user_assertion_attributes &&
        group_assertion_attributes == other.group_assertion_attributes
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [metadata, partner_provider_id, partner_provider_pattern, tenant_provider_id, succinct_id, assertion_consumer_url, logout_request_url, logout_response_url, name_id_format, signing_certificate, encryption_certificate, encryption_algorithm, key_encryption_algorithm, encrypt_assertion, sign_response_or_assertion, include_signing_cert_in_signature, logout_binding, logout_enabled, signature_hash_algorithm, federation_protocol, name_id_userstore_attribute, hok_required, hok_acs_url, last_notification_sent_time, outbound_assertion_attributes, user_assertion_attributes, group_assertion_attributes].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
