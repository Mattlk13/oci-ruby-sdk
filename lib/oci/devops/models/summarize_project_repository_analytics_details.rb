# Copyright (c) 2016, 2025, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20210630
require 'date'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Details of the user configured settings for viewing the metrics at project level.
  class Devops::Models::SummarizeProjectRepositoryAnalyticsDetails
    REPOSITORY_METRICS_ENUM = [
      REPOSITORY_METRICS_COMMITS = 'COMMITS'.freeze,
      REPOSITORY_METRICS_LINES_ADDED = 'LINES_ADDED'.freeze,
      REPOSITORY_METRICS_LINES_DELETED = 'LINES_DELETED'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_CREATED = 'PULL_REQUEST_CREATED'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_MERGED = 'PULL_REQUEST_MERGED'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_DECLINED = 'PULL_REQUEST_DECLINED'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_REVIEW_START_DURATION_IN_DAYS = 'PULL_REQUEST_REVIEW_START_DURATION_IN_DAYS'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_REVIEW_DURATION_IN_DAYS = 'PULL_REQUEST_REVIEW_DURATION_IN_DAYS'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_APPROVED = 'PULL_REQUEST_APPROVED'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_REVIEWED = 'PULL_REQUEST_REVIEWED'.freeze,
      REPOSITORY_METRICS_PULL_REQUEST_COMMENTS = 'PULL_REQUEST_COMMENTS'.freeze
    ].freeze

    AGGREGATION_DURATION_ENUM = [
      AGGREGATION_DURATION_DAILY = 'DAILY'.freeze,
      AGGREGATION_DURATION_WEEKLY = 'WEEKLY'.freeze,
      AGGREGATION_DURATION_MONTHLY = 'MONTHLY'.freeze,
      AGGREGATION_DURATION_YEARLY = 'YEARLY'.freeze
    ].freeze

    GROUP_BY_ENUM = [
      GROUP_BY_AUTHOR = 'AUTHOR'.freeze
    ].freeze

    # Email address of the author.
    # @return [String]
    attr_accessor :author_email

    # **[Required]** The name of the metric to be filtered.
    # @return [Array<String>]
    attr_reader :repository_metrics

    # Metrics aggregated for the defined period.
    # @return [String]
    attr_reader :aggregation_duration

    # **[Required]** The beginning of the metric data query time range.
    # @return [DateTime]
    attr_accessor :start_time

    # The end of the metric data query time range.
    # @return [DateTime]
    attr_accessor :end_time

    # Attribute by which metric data has to be grouped
    # @return [String]
    attr_reader :group_by

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'author_email': :'authorEmail',
        'repository_metrics': :'repositoryMetrics',
        'aggregation_duration': :'aggregationDuration',
        'start_time': :'startTime',
        'end_time': :'endTime',
        'group_by': :'groupBy'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'author_email': :'String',
        'repository_metrics': :'Array<String>',
        'aggregation_duration': :'String',
        'start_time': :'DateTime',
        'end_time': :'DateTime',
        'group_by': :'String'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :author_email The value to assign to the {#author_email} property
    # @option attributes [Array<String>] :repository_metrics The value to assign to the {#repository_metrics} property
    # @option attributes [String] :aggregation_duration The value to assign to the {#aggregation_duration} property
    # @option attributes [DateTime] :start_time The value to assign to the {#start_time} property
    # @option attributes [DateTime] :end_time The value to assign to the {#end_time} property
    # @option attributes [String] :group_by The value to assign to the {#group_by} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      self.author_email = attributes[:'authorEmail'] if attributes[:'authorEmail']

      raise 'You cannot provide both :authorEmail and :author_email' if attributes.key?(:'authorEmail') && attributes.key?(:'author_email')

      self.author_email = attributes[:'author_email'] if attributes[:'author_email']

      self.repository_metrics = attributes[:'repositoryMetrics'] if attributes[:'repositoryMetrics']

      raise 'You cannot provide both :repositoryMetrics and :repository_metrics' if attributes.key?(:'repositoryMetrics') && attributes.key?(:'repository_metrics')

      self.repository_metrics = attributes[:'repository_metrics'] if attributes[:'repository_metrics']

      self.aggregation_duration = attributes[:'aggregationDuration'] if attributes[:'aggregationDuration']

      raise 'You cannot provide both :aggregationDuration and :aggregation_duration' if attributes.key?(:'aggregationDuration') && attributes.key?(:'aggregation_duration')

      self.aggregation_duration = attributes[:'aggregation_duration'] if attributes[:'aggregation_duration']

      self.start_time = attributes[:'startTime'] if attributes[:'startTime']

      raise 'You cannot provide both :startTime and :start_time' if attributes.key?(:'startTime') && attributes.key?(:'start_time')

      self.start_time = attributes[:'start_time'] if attributes[:'start_time']

      self.end_time = attributes[:'endTime'] if attributes[:'endTime']

      raise 'You cannot provide both :endTime and :end_time' if attributes.key?(:'endTime') && attributes.key?(:'end_time')

      self.end_time = attributes[:'end_time'] if attributes[:'end_time']

      self.group_by = attributes[:'groupBy'] if attributes[:'groupBy']

      raise 'You cannot provide both :groupBy and :group_by' if attributes.key?(:'groupBy') && attributes.key?(:'group_by')

      self.group_by = attributes[:'group_by'] if attributes[:'group_by']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] repository_metrics Object to be assigned
    def repository_metrics=(repository_metrics)
      # rubocop:disable Style/ConditionalAssignment
      if repository_metrics.nil?
        @repository_metrics = nil
      else
        repository_metrics.each do |item|
          raise "Invalid value for 'repository_metrics': this must be one of the values in REPOSITORY_METRICS_ENUM." unless REPOSITORY_METRICS_ENUM.include?(item)
        end
        @repository_metrics = repository_metrics
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] aggregation_duration Object to be assigned
    def aggregation_duration=(aggregation_duration)
      raise "Invalid value for 'aggregation_duration': this must be one of the values in AGGREGATION_DURATION_ENUM." if aggregation_duration && !AGGREGATION_DURATION_ENUM.include?(aggregation_duration)

      @aggregation_duration = aggregation_duration
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] group_by Object to be assigned
    def group_by=(group_by)
      raise "Invalid value for 'group_by': this must be one of the values in GROUP_BY_ENUM." if group_by && !GROUP_BY_ENUM.include?(group_by)

      @group_by = group_by
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        author_email == other.author_email &&
        repository_metrics == other.repository_metrics &&
        aggregation_duration == other.aggregation_duration &&
        start_time == other.start_time &&
        end_time == other.end_time &&
        group_by == other.group_by
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [author_email, repository_metrics, aggregation_duration, start_time, end_time, group_by].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
