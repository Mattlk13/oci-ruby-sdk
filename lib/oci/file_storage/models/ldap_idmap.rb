# Copyright (c) 2016, 2023, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20171215
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Mount target details about the LDAP ID mapping configuration.
  #
  class FileStorage::Models::LdapIdmap
    SCHEMA_TYPE_ENUM = [
      SCHEMA_TYPE_RFC2307 = 'RFC2307'.freeze,
      SCHEMA_TYPE_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # Schema type of the LDAP account.
    # @return [String]
    attr_reader :schema_type

    # The amount of time that the mount target should allow an entry to persist in its cache before attempting to refresh the entry.
    # @return [Integer]
    attr_accessor :cache_refresh_interval_seconds

    # The maximum amount of time the mount target is allowed to use a cached entry.
    # @return [Integer]
    attr_accessor :cache_lifetime_seconds

    # The amount of time that a mount target will maintain information that a user is not found in the ID mapping configuration.
    # @return [Integer]
    attr_accessor :negative_cache_lifetime_seconds

    # All LDAP searches are recursive starting at this user.
    #
    # Example: `CN=User,DC=domain,DC=com`
    #
    # @return [String]
    attr_accessor :user_search_base

    # All LDAP searches are recursive starting at this group.
    #
    # Example: `CN=Group,DC=domain,DC=com`
    #
    # @return [String]
    attr_accessor :group_search_base

    # The [OCID](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm) of the first connector to use to communicate with the LDAP server.
    # @return [String]
    attr_accessor :outbound_connector1_id

    # The [OCID](https://docs.cloud.oracle.com/Content/General/Concepts/identifiers.htm) of the second connector to use to communicate with the LDAP server.
    # @return [String]
    attr_accessor :outbound_connector2_id

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'schema_type': :'schemaType',
        'cache_refresh_interval_seconds': :'cacheRefreshIntervalSeconds',
        'cache_lifetime_seconds': :'cacheLifetimeSeconds',
        'negative_cache_lifetime_seconds': :'negativeCacheLifetimeSeconds',
        'user_search_base': :'userSearchBase',
        'group_search_base': :'groupSearchBase',
        'outbound_connector1_id': :'outboundConnector1Id',
        'outbound_connector2_id': :'outboundConnector2Id'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'schema_type': :'String',
        'cache_refresh_interval_seconds': :'Integer',
        'cache_lifetime_seconds': :'Integer',
        'negative_cache_lifetime_seconds': :'Integer',
        'user_search_base': :'String',
        'group_search_base': :'String',
        'outbound_connector1_id': :'String',
        'outbound_connector2_id': :'String'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :schema_type The value to assign to the {#schema_type} property
    # @option attributes [Integer] :cache_refresh_interval_seconds The value to assign to the {#cache_refresh_interval_seconds} property
    # @option attributes [Integer] :cache_lifetime_seconds The value to assign to the {#cache_lifetime_seconds} property
    # @option attributes [Integer] :negative_cache_lifetime_seconds The value to assign to the {#negative_cache_lifetime_seconds} property
    # @option attributes [String] :user_search_base The value to assign to the {#user_search_base} property
    # @option attributes [String] :group_search_base The value to assign to the {#group_search_base} property
    # @option attributes [String] :outbound_connector1_id The value to assign to the {#outbound_connector1_id} property
    # @option attributes [String] :outbound_connector2_id The value to assign to the {#outbound_connector2_id} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.schema_type = attributes[:'schemaType'] if attributes[:'schemaType']
      self.schema_type = "RFC2307" if schema_type.nil? && !attributes.key?(:'schemaType') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :schemaType and :schema_type' if attributes.key?(:'schemaType') && attributes.key?(:'schema_type')

      self.schema_type = attributes[:'schema_type'] if attributes[:'schema_type']
      self.schema_type = "RFC2307" if schema_type.nil? && !attributes.key?(:'schemaType') && !attributes.key?(:'schema_type') # rubocop:disable Style/StringLiterals

      self.cache_refresh_interval_seconds = attributes[:'cacheRefreshIntervalSeconds'] if attributes[:'cacheRefreshIntervalSeconds']

      raise 'You cannot provide both :cacheRefreshIntervalSeconds and :cache_refresh_interval_seconds' if attributes.key?(:'cacheRefreshIntervalSeconds') && attributes.key?(:'cache_refresh_interval_seconds')

      self.cache_refresh_interval_seconds = attributes[:'cache_refresh_interval_seconds'] if attributes[:'cache_refresh_interval_seconds']

      self.cache_lifetime_seconds = attributes[:'cacheLifetimeSeconds'] if attributes[:'cacheLifetimeSeconds']

      raise 'You cannot provide both :cacheLifetimeSeconds and :cache_lifetime_seconds' if attributes.key?(:'cacheLifetimeSeconds') && attributes.key?(:'cache_lifetime_seconds')

      self.cache_lifetime_seconds = attributes[:'cache_lifetime_seconds'] if attributes[:'cache_lifetime_seconds']

      self.negative_cache_lifetime_seconds = attributes[:'negativeCacheLifetimeSeconds'] if attributes[:'negativeCacheLifetimeSeconds']

      raise 'You cannot provide both :negativeCacheLifetimeSeconds and :negative_cache_lifetime_seconds' if attributes.key?(:'negativeCacheLifetimeSeconds') && attributes.key?(:'negative_cache_lifetime_seconds')

      self.negative_cache_lifetime_seconds = attributes[:'negative_cache_lifetime_seconds'] if attributes[:'negative_cache_lifetime_seconds']

      self.user_search_base = attributes[:'userSearchBase'] if attributes[:'userSearchBase']

      raise 'You cannot provide both :userSearchBase and :user_search_base' if attributes.key?(:'userSearchBase') && attributes.key?(:'user_search_base')

      self.user_search_base = attributes[:'user_search_base'] if attributes[:'user_search_base']

      self.group_search_base = attributes[:'groupSearchBase'] if attributes[:'groupSearchBase']

      raise 'You cannot provide both :groupSearchBase and :group_search_base' if attributes.key?(:'groupSearchBase') && attributes.key?(:'group_search_base')

      self.group_search_base = attributes[:'group_search_base'] if attributes[:'group_search_base']

      self.outbound_connector1_id = attributes[:'outboundConnector1Id'] if attributes[:'outboundConnector1Id']

      raise 'You cannot provide both :outboundConnector1Id and :outbound_connector1_id' if attributes.key?(:'outboundConnector1Id') && attributes.key?(:'outbound_connector1_id')

      self.outbound_connector1_id = attributes[:'outbound_connector1_id'] if attributes[:'outbound_connector1_id']

      self.outbound_connector2_id = attributes[:'outboundConnector2Id'] if attributes[:'outboundConnector2Id']

      raise 'You cannot provide both :outboundConnector2Id and :outbound_connector2_id' if attributes.key?(:'outboundConnector2Id') && attributes.key?(:'outbound_connector2_id')

      self.outbound_connector2_id = attributes[:'outbound_connector2_id'] if attributes[:'outbound_connector2_id']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] schema_type Object to be assigned
    def schema_type=(schema_type)
      # rubocop:disable Style/ConditionalAssignment
      if schema_type && !SCHEMA_TYPE_ENUM.include?(schema_type)
        OCI.logger.debug("Unknown value for 'schema_type' [" + schema_type + "]. Mapping to 'SCHEMA_TYPE_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @schema_type = SCHEMA_TYPE_UNKNOWN_ENUM_VALUE
      else
        @schema_type = schema_type
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        schema_type == other.schema_type &&
        cache_refresh_interval_seconds == other.cache_refresh_interval_seconds &&
        cache_lifetime_seconds == other.cache_lifetime_seconds &&
        negative_cache_lifetime_seconds == other.negative_cache_lifetime_seconds &&
        user_search_base == other.user_search_base &&
        group_search_base == other.group_search_base &&
        outbound_connector1_id == other.outbound_connector1_id &&
        outbound_connector2_id == other.outbound_connector2_id
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [schema_type, cache_refresh_interval_seconds, cache_lifetime_seconds, negative_cache_lifetime_seconds, user_search_base, group_search_base, outbound_connector1_id, outbound_connector2_id].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
