# Copyright (c) 2016, 2025, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20230801
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Approval info for initial access or extension of a Delegated Resource Access Request
  #
  class DelegateAccessControl::Models::DelegatedResourceAccessRequestApprovalDetails
    APPROVAL_ACTION_ENUM = [
      APPROVAL_ACTION_APPROVE = 'APPROVE'.freeze,
      APPROVAL_ACTION_REJECT = 'REJECT'.freeze,
      APPROVAL_ACTION_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    APPROVAL_TYPE_ENUM = [
      APPROVAL_TYPE_INITIAL = 'INITIAL'.freeze,
      APPROVAL_TYPE_EXTENSION = 'EXTENSION'.freeze,
      APPROVAL_TYPE_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # Indicated whether the request is approved or rejected.
    # @return [String]
    attr_reader :approval_action

    # Access start time that is actually approved by the customer in [RFC 3339](https://tools.ietf.org/html/rfc3339)timestamp format, e.g. '2020-05-22T21:10:29.600Z'.
    # @return [DateTime]
    attr_accessor :time_approved_for_access

    # approval type, initial or extension
    # @return [String]
    attr_reader :approval_type

    # **[Required]** Comment specified by the approver of the request.
    # @return [String]
    attr_accessor :approver_comment

    # User ID of the approver.
    # @return [String]
    attr_accessor :approver_id

    # Additional message specified by the approver of the request.
    # @return [String]
    attr_accessor :approver_additional_message

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'approval_action': :'approvalAction',
        'time_approved_for_access': :'timeApprovedForAccess',
        'approval_type': :'approvalType',
        'approver_comment': :'approverComment',
        'approver_id': :'approverId',
        'approver_additional_message': :'approverAdditionalMessage'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'approval_action': :'String',
        'time_approved_for_access': :'DateTime',
        'approval_type': :'String',
        'approver_comment': :'String',
        'approver_id': :'String',
        'approver_additional_message': :'String'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :approval_action The value to assign to the {#approval_action} property
    # @option attributes [DateTime] :time_approved_for_access The value to assign to the {#time_approved_for_access} property
    # @option attributes [String] :approval_type The value to assign to the {#approval_type} property
    # @option attributes [String] :approver_comment The value to assign to the {#approver_comment} property
    # @option attributes [String] :approver_id The value to assign to the {#approver_id} property
    # @option attributes [String] :approver_additional_message The value to assign to the {#approver_additional_message} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.approval_action = attributes[:'approvalAction'] if attributes[:'approvalAction']

      raise 'You cannot provide both :approvalAction and :approval_action' if attributes.key?(:'approvalAction') && attributes.key?(:'approval_action')

      self.approval_action = attributes[:'approval_action'] if attributes[:'approval_action']

      self.time_approved_for_access = attributes[:'timeApprovedForAccess'] if attributes[:'timeApprovedForAccess']

      raise 'You cannot provide both :timeApprovedForAccess and :time_approved_for_access' if attributes.key?(:'timeApprovedForAccess') && attributes.key?(:'time_approved_for_access')

      self.time_approved_for_access = attributes[:'time_approved_for_access'] if attributes[:'time_approved_for_access']

      self.approval_type = attributes[:'approvalType'] if attributes[:'approvalType']

      raise 'You cannot provide both :approvalType and :approval_type' if attributes.key?(:'approvalType') && attributes.key?(:'approval_type')

      self.approval_type = attributes[:'approval_type'] if attributes[:'approval_type']

      self.approver_comment = attributes[:'approverComment'] if attributes[:'approverComment']

      raise 'You cannot provide both :approverComment and :approver_comment' if attributes.key?(:'approverComment') && attributes.key?(:'approver_comment')

      self.approver_comment = attributes[:'approver_comment'] if attributes[:'approver_comment']

      self.approver_id = attributes[:'approverId'] if attributes[:'approverId']

      raise 'You cannot provide both :approverId and :approver_id' if attributes.key?(:'approverId') && attributes.key?(:'approver_id')

      self.approver_id = attributes[:'approver_id'] if attributes[:'approver_id']

      self.approver_additional_message = attributes[:'approverAdditionalMessage'] if attributes[:'approverAdditionalMessage']

      raise 'You cannot provide both :approverAdditionalMessage and :approver_additional_message' if attributes.key?(:'approverAdditionalMessage') && attributes.key?(:'approver_additional_message')

      self.approver_additional_message = attributes[:'approver_additional_message'] if attributes[:'approver_additional_message']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] approval_action Object to be assigned
    def approval_action=(approval_action)
      # rubocop:disable Style/ConditionalAssignment
      if approval_action && !APPROVAL_ACTION_ENUM.include?(approval_action)
        OCI.logger.debug("Unknown value for 'approval_action' [" + approval_action + "]. Mapping to 'APPROVAL_ACTION_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @approval_action = APPROVAL_ACTION_UNKNOWN_ENUM_VALUE
      else
        @approval_action = approval_action
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] approval_type Object to be assigned
    def approval_type=(approval_type)
      # rubocop:disable Style/ConditionalAssignment
      if approval_type && !APPROVAL_TYPE_ENUM.include?(approval_type)
        OCI.logger.debug("Unknown value for 'approval_type' [" + approval_type + "]. Mapping to 'APPROVAL_TYPE_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @approval_type = APPROVAL_TYPE_UNKNOWN_ENUM_VALUE
      else
        @approval_type = approval_type
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        approval_action == other.approval_action &&
        time_approved_for_access == other.time_approved_for_access &&
        approval_type == other.approval_type &&
        approver_comment == other.approver_comment &&
        approver_id == other.approver_id &&
        approver_additional_message == other.approver_additional_message
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [approval_action, time_approved_for_access, approval_type, approver_comment, approver_id, approver_additional_message].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
